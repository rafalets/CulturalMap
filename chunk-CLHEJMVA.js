import{a as Qt}from"./chunk-3BZ4FXCE.js";import{A as gt,Bb as X,C as N,Cb as x,Fa as pt,Gb as S,Hb as at,Ia as U,Ja as Pt,K as ot,Ka as Wt,La as xt,Ma as Jt,Na as K,Oa as Q,Pa as Z,Qa as Ut,R as mt,Ra as jt,T as Ot,V as Ft,Xa as bt,Ya as j,a as G,ab as q,bb as Ht,i as rt,kb as $,lb as Lt,m as L,n as B,p as W,pb as Vt,q as Xt,r as Yt,s as dt,vb as Kt,za as V}from"./chunk-UNRRVLTB.js";import{a as Gt,b as Mt}from"./chunk-6DVIB4O4.js";import{Da as Bt,Fa as k,Ia as A,Ja as O,b as T,d as Nt,g as Tt,h as kt,i as F,l as At,n as Et,o as it,s as qt,tb as y,u as Rt,ub as J,y as ft,ya as zt}from"./chunk-JLMESEWM.js";import{d as v,e as E}from"./chunk-QGVBCWUY.js";import"./chunk-VTHXE323.js";function oe(p,t,s,e,m,o){e<Number.MAX_VALUE&&e>-Number.MAX_VALUE||it("Geodesic_bufferer.buffer - bad distance"),ft(p);let i=Qt(p),r=i.getGeometryType();if(kt(r)){let n=i.getPointCount(),u=8e6;if(Math.abs(e)>u&&(n>50||r!==T.enumMultiPoint&&s===4&&n>2)){let a=i,l=e>0?1:-1,h=7e6,_=e,c=1;do c++,_=(Math.abs(_)-h)*l;while(Math.abs(_)>u);_=e;for(let f=0;f<c-1;f++)a=yt(a,t,s,h*l,m,c,o),_=(Math.abs(_)-h)*l;return a=yt(a,t,s,_,m,c,o),a}}return yt(i,t,s,e,m,1,o)}var wt=class{constructor(t){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_radTolerance=0,this.m_q90=0,this.m_gcs90=0,this.m_gcs180=0,this.m_gcs360=0,this.m_gcs60=0,this.m_ellipticToGeodesicMaxRatio=0,this.m_curveType=0,this.m_bShapePreserving=!1,this.m_distance=0,this.m_absDistance=0,this.m_convergenceOffset=0,this.m_cornerStep=0,this.m_segmentStep=0,this.m_progressTracker=t}bufferPolygon(t){let s=new N,e=new ut(this,t,s);return this.processGnomonicBufferPiecesCursor(!0,e)}bufferPolyline(t){let s=new ut(this,t,null);return this.processGnomonicBufferPiecesCursor(!0,s)}bufferMultiPoint(t){let s=new vt(this,t);return this.processGnomonicBufferPiecesCursor(!1,s)}bufferPoint(t){let s=t.getXY();s.scale(this.m_rpu);let e=new N;if(this.bufferPoint2D(s,!1,e)){let m=B(null,e,!0);e=V(e,m,!0,!0,-1,this.m_progressTracker,0,!1)}return e=new U().foldInto360RangeGeodetic(e,this.m_gcs,2),e}processGnomonicBufferPiecesCursor(t,s){let e=s,m=e.getGnomonic(),o=Kt(Ft()),i=new $,r=new j().executeMany(i,o,this.m_progressTracker,2),n=Bt(6,!1),u=zt(G,6);this.initializeGrid(n,u);let a=[null,null,null,null,null,null],l=[null,null,null,null,null,null],h=[null,null,null,null,null,null],_,c,f;for(;(_=e.next())!==null;){if(c=e.getGnomonic(),c!==m){if(m!==null){let d=r.next();if(i=null,r=null,d!=null){let C=B(o,d,!0),P=W(C);d=m.unproject(d,P,this.m_progressTracker),this.putInGridCursors(t,d,o,!0,n,u,a,l,h)}}c!==null&&(i=new $,r=new j().executeMany(i,o,this.m_progressTracker,2)),m=c}if(e.isRunningInGnomonic()){if(c.project(_),e.needsSimplify()){let d=B(null,_,!0);_=V(_,d,!0,!0,-1,this.m_progressTracker,0,!1)}i.tick(ht(_)),r.tock()}else this.putInGridCursors(t,_,o,!0,n,u,a,l,h)}let g=!1;for(let d=0;d<6;d++)if(h[d]!=null){g=!0;break}if(g){let d=!1,C=[null,null,null,null,null,null];if(t){let b=e.m_densified;if(e.m_densified=null,b!==null){let w=new J;w.scale(1/this.m_rpu,1/this.m_rpu),b.applyTransformation(w),this.m_distance>0?this.putInGridCursors(t,b,o,!1,n,u,a,l,h):(this.processInGrid(t,b,!1,n,u,a,C),d=!0)}}let P=new $,D=new j().executeMany(P,this.m_gcs,this.m_progressTracker,2);if(r!==null){let b=r.next();i=null,r=null;let w=B(o,b,!0),M=W(w);b=m.unproject(b,M,this.m_progressTracker),this.putInGridCursors(t,b,o,!0,n,u,a,l,h)}for(let b=0;b<6;b++)if(h[b]!=null){let w=h[b].next();h[b]=null,l[b]=null,d&&C[b]!==null&&(w=new bt().execute(C[b],w,o,this.m_progressTracker));let M=B(o,w,!0),I=W(M);w=a[b].unproject(w,I,this.m_progressTracker),w=new pt().execute(w,this.m_gcs,!0,this.m_progressTracker),P.tick(ht(w)),D.tock()}f=D.next()}else{let d,C=!1;if(t){let w=e.m_densified;if(e.m_densified=null,w!==null){let M=new J;M.scale(1/this.m_rpu,1/this.m_rpu),w.applyTransformation(M),c.project(w);let I=B(null,w,!0);w=V(w,I,!1,!0,-1,this.m_progressTracker,0,!1),this.m_distance>0?(i.tick(ht(w)),r.tock()):(d=w,C=!0)}}let P=r.next();i=null,r=null,C&&(P=new bt().execute(d,P,o,this.m_progressTracker));let D=B(o,P,!0),b=W(D);f=m.unproject(P,b,this.m_progressTracker),f=new pt().execute(f,this.m_gcs,!0,this.m_progressTracker)}return f=new U().foldInto360RangeGeodetic(f,this.m_gcs,2),f}putInGridCursors(t,s,e,m,o,i,r,n,u){let a=[null,null,null,null,null,null];this.processInGrid(t,s,m,o,i,r,a);for(let l=0;l<6;l++)a[l]!==null&&(n[l]===null&&(n[l]=new $,u[l]=new j().executeMany(n[l],e,this.m_progressTracker,2)),n[l].tick(ht(a[l])),u[l].tock())}processInGrid(t,s,e,m,o,i,r){let u=this.insertGeodeticPointsAlongGrid(s,o,.01);for(let a=0;a<6;a++){if(m[a])continue;let l=o[a].clone();l.inflateCoords(.01,.01);let h=rt(s,l),_=L(null,h,!1).total(),c=mt(u,l,_,Number.NaN,this.m_progressTracker);if(c!==null&&!c.isEmpty()){if(c===u&&(c=c.clone()),i[a]===null){let g=new y;a<3?g.setCoords(0,1):g.setCoords(0,-1);let d=new y;d.setAdd(o[a].getCenter(),g),i[a]=et(this.m_gcs,d)}i[a].project(c);let f=B(null,c,!0);c=V(c,f,e,!0,-1,this.m_progressTracker,0,!1),r[a]=c}}}insertGeodeticPointsAlongGrid(t,s,e){let m=G.construct(s[3].xmin,s[3].ymin,s[2].xmax,s[2].ymax),o=Ut(this.m_gcs,m,t,!0,this.m_progressTracker),i=new ot,r=i.addGeometry(o);return q(i,r,this.m_gcs,0,2,!0,s[0].xmax+e),q(i,r,this.m_gcs,0,2,!0,s[1].xmax+e),q(i,r,this.m_gcs,0,2,!1,s[1].ymin+e),e!==0&&(q(i,r,this.m_gcs,0,2,!0,s[0].xmax-e),q(i,r,this.m_gcs,0,2,!0,s[1].xmax-e),q(i,r,this.m_gcs,0,2,!1,s[1].ymin-e)),i.getGeometry(r)}initializeGrid(t,s){for(let e=0;e<6;e++)t[e]=!1;s[0].setCoords({xmin:-this.m_gcs180,ymin:0,xmax:-this.m_gcs60,ymax:this.m_gcs90}),s[1].setCoords({xmin:-this.m_gcs60,ymin:0,xmax:this.m_gcs60,ymax:this.m_gcs90}),s[2].setCoords({xmin:this.m_gcs60,ymin:0,xmax:this.m_gcs180,ymax:this.m_gcs90}),s[3].setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:-this.m_gcs60,ymax:0}),s[4].setCoords({xmin:-this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs60,ymax:0}),s[5].setCoords({xmin:this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:0})}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(t,s,e,m,o,i){let r=t[0],n=t.at(-1),u=r.y<n.y?r.y:n.y,a=r.y>n.y?r.y:n.y,l=at.q(this.m_a,this.m_eSquared,u),h=at.q(this.m_a,this.m_eSquared,a);if(this.m_q90-(l+s+this.m_absDistance)>.001&&this.m_q90+(h-s-this.m_absDistance)>.001)return!1;let _=e-O,c=m+O,f=_-Math.PI,g=_+Math.PI,d=c+Math.PI,C=[Number.NaN],P=[Number.NaN],D=[Number.NaN],b=[Number.NaN],w=!1;if(Zt(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,r,_,f,n,c,C,P),Zt(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,n,d,c,r,f,D,b),(c<C[0]&&C[0]<d||c<P[0]&&P[0]<d)&&(w=!0),w||(f<D[0]&&D[0]<_||f<b[0]&&b[0]<_)&&(w=!0),!w&&o)return!1;let M=[];for(let R=t.length-1;R>=0;R--)M.push(t[R]);i.setEmpty(),i.addPathPoint2D(null,0,!0);let I=0;I=Ct(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,t,_,c,o,I,i),I=tt(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,n,c,d,this.m_cornerStep,o,I,i,C[0],P[0]),I=Ct(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,M,d,g,o,I,i),I=tt(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,r,f,_,this.m_cornerStep,o,I,i,D[0],b[0]);let Y=!1;return o||(Y=this.checkAndPrepForPole(i)),w||Y}bufferPoint2D(t,s,e){e.setEmpty(),e.addPathPoint2D(null,0,!0),tt(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,t,-this.m_cornerStep,2*Math.PI,this.m_cornerStep,s,0,e);let o=!1;return s||(o=this.checkAndPrepForPole(e)),o}checkAndPrepForPole(t){let s=this.checkAndPrepForPoleTouch(t),e=this.checkAndPrepForPoleWrap(t);return s||e}checkAndPrepForPoleTouch(t){let s=new G;return t.queryEnvelope(s),!(!X(s.ymax,this.m_gcs90)&&!X(s.ymin,-this.m_gcs90))&&(this.prepPoleTouch(t),!0)}checkAndPrepForPoleWrap(t){let s=t.getXY(0),e=t.getXY(t.getPointCount()-1);return Math.abs(s.x-e.x)>this.m_gcs180?(this.prepSinglePoleWrap(t),!0):this.checkAndPrepForDoublePoleWrap(t)}checkAndPrepForDoublePoleWrap(t){return t.calculateArea2D()<0&&(this.prepDoublePoleWrap(t),!0)}prepPoleTouch(t){let s=new N;s.insertPath2D(-1,null,0,0,!0);let e=t.getPathStart(0),m=t.getPathEnd(0),o=m-e,i=-1;for(i=e;i<m;i++){let a=t.getXY(i),l=X(a.y,this.m_gcs90),h=X(a.y,-this.m_gcs90);if(!l&&!h)break}let r=i,n=!1,u=Number.NaN;do{let a=t.getXY(r),l=X(a.y,this.m_gcs90),h=X(a.y,-this.m_gcs90),_=e+(r+1-e)%o;if(l||h){let c=y.construct(u,a.y);s.insertPoint2D(0,-1,c);let f=t.getXY(_),g=X(f.y,this.m_gcs90),d=X(f.y,-this.m_gcs90);g||d||(c=y.construct(f.x,a.y),n?s.setXY(s.getPointCount()-1,c):s.insertPoint2D(0,-1,c)),n=!0}else s.insertPoint2D(0,-1,a),u=a.x,n=!1;r=_}while(r!==i);t.setEmpty(),t.add(s,!1)}prepSinglePoleWrap(t){let s=new N,e=new N,m=new J,o=t.getXY(t.getPathStart(0)),i=t.getXY(t.getPathEnd(0)-1),r=this.m_gcs360,n=this.m_gcs180,u=new G;u.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});let a=new G;t.queryEnvelope(a);let l=Math.ceil(a.width()/r),h,_;o.x>i.x?(h=-r,_=this.m_gcs90):(h=r,_=-this.m_gcs90),m.setShiftCoords(h,0),s.addPath(t,0,!0),e.add(s,!1);let c=new dt;for(let z=0;z<l;z++)e.applyTransformation(m),e.getPointByVal(0,c),s.lineToPoint(c),s.addSegmentsFromPath(e,0,0,e.getSegmentCount()-1,!1);let f=s.getXY(0),g=s.getXY(s.getPointCount()-1);f.y=_,g.y=_,s.lineTo(g);let d=new y;for(d.setCoordsPoint2D(g),d.x-=.5*h;Math.abs(d.x-f.x)>n;)s.lineTo(d),d.x-=.5*h;s.lineTo(f);let C=u.getCenterX(),P=new G;s.queryEnvelope(P);let D=0,b=P.getCenter().x;b-C>n?D=-Math.ceil((b-C-n)/r):C-b>n&&(D=Math.ceil((C-b-n)/r)),D!==0&&(m.setShiftCoords(D*r,0),s.applyTransformation(m));let w=new ot,M=w.addGeometry(s);q(w,M,this.m_gcs,0,2,!0,u.xmin),q(w,M,this.m_gcs,0,2,!0,u.xmax);let I=w.getGeometry(M),Y=rt(I,u);Y.inflateCoords(0,1);let R=L(null,Y,!0).total(),H=mt(I,u,R,Number.NaN,this.m_progressTracker);t.setEmpty(),t.add(H,!1)}prepDoublePoleWrap(t){let s=this.m_gcs360,e=this.m_gcs180,m=new G;m.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});let o=m.getCenter().x,i=new G;t.queryPathEnvelope(0,i);let r,n=0,u=i.getCenter().x;if(u-o>e?n=-Math.ceil((u-o-e)/s):o-u>e&&(n=Math.ceil((o-u-e)/s)),n!==0){let _=new J;_.setShiftCoords(n*s,0),t.getImpl().applyTransformationToPath(_,0),t.queryPathEnvelope(0,i),u=i.getCenter().x}let a=new G;m.containsExclusiveEnvelope(i)?(r=!1,a.setCoords({env2D:m})):(r=!0,a.setCoords({env2D:m}),a.xmin-=s,a.xmax+=s);let l=t.createInstance();l.addPathPoint2D(null,0,!0);let h=new y;if(h.setCoords(a.xmin,a.ymin),l.insertPoint2D(0,-1,h),h.setCoords(a.xmin,a.ymax),l.insertPoint2D(0,-1,h),h.setCoords(.5*(a.xmin+a.xmax),a.ymax),l.insertPoint2D(0,-1,h),h.setCoords(a.xmax,a.ymax),l.insertPoint2D(0,-1,h),h.setCoords(a.xmax,a.ymin),l.insertPoint2D(0,-1,h),h.setCoords(.5*(a.xmin+a.xmax),a.ymin),l.insertPoint2D(0,-1,h),r){l.addPath(t,0,!0);let _=new J;u<o?_.setShiftCoords(s,0):_.setShiftCoords(-s,0),t.getImpl().applyTransformationToPath(_,0),l.addPath(t,0,!0);let c=new ot,f=c.addGeometry(l);q(c,f,this.m_gcs,0,2,!0,m.xmin),q(c,f,this.m_gcs,0,2,!0,m.xmax),l=c.getGeometry(f);let g=rt(l,m);g.inflateCoords(0,1);let d=L(null,g,!0).total();l=mt(l,m,d,Number.NaN,this.m_progressTracker)}else l.addPath(t,0,!0);t.setEmpty(),t.add(l,!1)}setMinCornerStep(){let t={stack:[],error:void 0,hasError:!1};try{let s=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);s=Math.min(s,.125*this.m_a*Math.PI);let e=new y;e.setCoords(0,10*this.m_rpu);let m=0,o=45*this.m_rpu,i=v(t,new k(new x,new x),!1),r=v(t,new k(new x,new x),!1),n=v(t,new k(new x,new x),!1),u=v(t,new k(new x,new x),!1),a=new y,l=new y,h=new y,_=new y;for(S.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,m,i.at(0),i.at(1)),a.setCoords(i.at(0).val,i.at(1).val),S.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,o,r.at(0),r.at(1)),l.setCoords(r.at(0).val,r.at(1).val);;){let g={stack:[],error:void 0,hasError:!1};try{let d=.5*(m+o);S.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,d,n.at(0),n.at(1)),h.setCoords(n.at(0).val,n.at(1).val);let C=v(g,new x,!1),P=v(g,new x,!1);S.geodeticDistance(this.m_a,this.m_eSquared,a.x,a.y,l.x,l.y,C,P,null,2),S.geodeticCoordinate(this.m_a,this.m_eSquared,a.x,a.y,.5*C.val,P.val,u.at(0),u.at(1),2),_.setCoords(u.at(0).val,u.at(1).val);let D=v(g,new x,!1);if(S.geodeticDistance(this.m_a,this.m_eSquared,h.x,h.y,_.x,_.y,D,null,null,2),D.val<=this.m_convergenceOffset)break;o*=.9,S.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,o,r.at(0),r.at(1)),l.setCoords(r.at(0).val,r.at(1).val)}catch(d){g.error=d,g.hasError=!0}finally{E(g)}}let c=o-m,f=2*Math.PI/Math.ceil(2*Math.PI/c);this.m_cornerStep=f}catch(s){t.error=s,t.hasError=!0}finally{E(t)}}setMinSegmentStep(){let t={stack:[],error:void 0,hasError:!1};try{let s=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);s=Math.min(s,.125*this.m_a*Math.PI);let e=new y,m=new y;e.setCoords(0,10*this.m_rpu),m.setCoords(10*this.m_rpu,10*this.m_rpu);let o=v(t,new x,!1),i=v(t,new x,!1),r=v(t,new x,!1);S.geodeticDistance(this.m_a,this.m_eSquared,e.x,e.y,m.x,m.y,r,o,i,this.m_curveType);let n=v(t,new k(new x,new x),!1),u=v(t,new k(new x,new x),!1),a=new y,l=v(t,new x,!1),h=v(t,new k(new x,new x),!1),_=v(t,new k(new x,new x),!1),c=v(t,new k(new x,new x),!1),f=v(t,new k(new x,new x),!1),g=new y,d=new y,C=new y,P=new y,D=0,b=1,w=o.val,M=i.val,I=w-.5*Math.PI,Y=M+.5*Math.PI,R=r.val;for(S.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,I,h.at(0),h.at(1)),g.setCoords(h.at(0).val,h.at(1).val),S.geodesicCoordinate(this.m_a,this.m_eSquared,m.x,m.y,s,Y,_.at(0),_.at(1)),d.setCoords(_.at(0).val,_.at(1).val);;){let z={stack:[],error:void 0,hasError:!1};try{let _t=.5*(D+b);S.geodeticCoordinate(this.m_a,this.m_eSquared,e.x,e.y,_t*R,w,n.at(0),n.at(1),this.m_curveType),a.setCoords(n.at(0).val,n.at(1).val),S.geodeticDistance(this.m_a,this.m_eSquared,e.x,e.y,a.x,a.y,null,null,l,this.m_curveType);let ie=l.val+.5*Math.PI;S.geodesicCoordinate(this.m_a,this.m_eSquared,a.x,a.y,s,ie,c.at(0),c.at(1)),C.setCoords(c.at(0).val,c.at(1).val);let St=v(z,new x,!1),Dt=v(z,new x,!1);S.geodeticDistance(this.m_a,this.m_eSquared,g.x,g.y,d.x,d.y,St,Dt,null,2),S.geodeticCoordinate(this.m_a,this.m_eSquared,g.x,g.y,.5*St.val,Dt.val,f.at(0),f.at(1),2),P.setCoords(f.at(0).val,f.at(1).val);let It=v(z,new x,!1);if(S.geodeticDistance(this.m_a,this.m_eSquared,C.x,C.y,P.x,P.y,It,null,null,2),It.val<=this.m_convergenceOffset)break;{let st={stack:[],error:void 0,hasError:!1};try{b*=.9,S.geodeticCoordinate(this.m_a,this.m_eSquared,e.x,e.y,b*R,w,u.at(0),u.at(1),this.m_curveType),m.setCoords(u.at(0).val,u.at(1).val);let nt=v(st,new x,!1);S.geodeticDistance(this.m_a,this.m_eSquared,e.x,e.y,m.x,m.y,null,null,nt,this.m_curveType);let re=nt.val+.5*Math.PI;S.geodesicCoordinate(this.m_a,this.m_eSquared,m.x,m.y,s,re,_.at(0),_.at(1)),d.setCoords(_.at(0).val,_.at(1).val)}catch(nt){st.error=nt,st.hasError=!0}finally{E(st)}}}catch(_t){z.error=_t,z.hasError=!0}finally{E(z)}}let H=b*R;H>1e5&&(H=1e5),this.m_segmentStep=H}catch(s){t.error=s,t.hasError=!0}finally{E(t)}}setConvergenceOffset(){let t;t=this.m_absDistance>5e4?100:this.m_absDistance>1e4?10:1,this.m_absDistance/t<500&&(t=this.m_absDistance/500),t<.01&&(t=.01),this.m_convergenceOffset=t}};function yt(p,t,s,e,m,o,i){if(p.isEmpty())return new N({vd:p.getDescription()});let r=p;if(At(r)){let g=10*t.getTolerance(0);r=new Ot().execute(r,0,g,0,i,12e3)}let n=new wt(i);n.m_sr=t,n.m_gcs=t.getGCS(),n.m_transform=Lt(t,n.m_gcs,null);let u=Vt();n.m_gcs.querySpheroidData(u);let a=new G;r.queryEnvelope(a),n.m_a=u.majorSemiAxis,n.m_eSquared=u.e2,n.m_rpu=n.m_gcs.getUnit().getUnitToBaseFactor(),n.m_gcs90=.5*Math.PI/n.m_rpu,n.m_gcs180=Math.PI/n.m_rpu,n.m_gcs360=2*Math.PI/n.m_rpu,n.m_gcs60=n.m_gcs360/6,n.m_q90=at.q90(n.m_a,n.m_eSquared),n.m_ellipticToGeodesicMaxRatio=.5*n.m_a*Math.PI/n.m_q90;let l=n.m_gcs.getTolerance(0);n.m_radTolerance=l*n.m_rpu,s===4?(n.m_curveType=2,n.m_bShapePreserving=!0):(n.m_curveType=s,n.m_bShapePreserving=!1),n.m_distance=e,n.m_absDistance=Math.abs(e),Number.isNaN(m)||m<=0?n.setConvergenceOffset():n.m_convergenceOffset=Math.max(m,.001),n.m_convergenceOffset/=o;let h,_=r.getGeometryType();if(Tt(_)){let g=new gt({vd:r.getDescription()});g.addSegment(r,!0),h=g,_=T.enumPolyline}else if(_===T.enumEnvelope){let g=r,d=new G;g.queryEnvelope(d);let C=W(L(n.m_sr,a,!0));if(d.minDimension()<=C)if(d.maxDimension()===0){let P=new dt({vd:r.getDescription()});g.getCenter(P),h=P,_=T.enumPoint}else{let P=new gt({vd:r.getDescription()});P.addEnvelope(g,!1),h=P,_=T.enumPolyline}else{let P=new N({vd:r.getDescription()});P.addEnvelope(g,!1),h=P,_=T.enumPolygon}}else h=r;if(n.setMinCornerStep(),Nt(_)||n.setMinSegmentStep(),n.m_absDistance<=.5*n.m_convergenceOffset)return _!==T.enumPolygon?new N({vd:h.getDescription()}):n.m_bShapePreserving?h:Pt(h,n.m_sr,n.m_curveType,n.m_segmentStep,-1,i);if(n.m_distance<0&&_!==T.enumPolygon)return new N({vd:h.getDescription()});if(n.m_bShapePreserving&&F(_)){let g=Pt(h,t,4,Number.NaN,n.m_convergenceOffset,i);h=new U().execute(g,n.m_transform,i)}else h=new U().execute(h,n.m_transform,i);if(h=Ht(h,n.m_gcs),h.isEmpty())return new N({vd:h.getDescription()});!n.m_bShapePreserving&&F(_)&&(h=Wt(n.m_rpu,h)),h=me(h,n.m_gcs);let c=new N;switch(_){case T.enumPolygon:c=n.bufferPolygon(h);break;case T.enumPolyline:c=n.bufferPolyline(h);break;case T.enumMultiPoint:c=n.bufferMultiPoint(h);break;case T.enumPoint:c=n.bufferPoint(h);break;default:Et("")}let f=new U().execute(c,n.m_transform.getInverse(),i);return f.mergeVertexDescription(h.getDescription()),f}function Ct(p,t,s,e,m,o,i,r,n,u,a){let l={stack:[],error:void 0,hasError:!1};try{let h=new y;h.setNAN(),n||a.getPointCount()>0&&(h.setCoordsPoint2D(a.getXY(a.getPointCount()-1)),h.scale(s));let _=v(l,new x,!1),c=v(l,new k(new x,new x),!1),f=new y,g=new y,d=o.at(-1),C=1/s;for(let P=0;P<o.length;P++){let D=o[P],b;P===0?b=i:P===o.length-1?b=r:(S.geodeticDistance(p,t,d.x,d.y,D.x,D.y,null,null,_,m),b=_.val-.5*Math.PI),S.geodesicCoordinate(p,t,D.x,D.y,e,b,c.at(0),c.at(1)),n?g.setCoords(c.at(0).val,c.at(1).val):(f.setCoords(c.at(0).val,c.at(1).val),u=ee(D.x,f.x,h.x,u),g.setCoords(u+f.x,f.y),h.setCoordsPoint2D(g)),g.scale(C),a.insertPoint2D(0,-1,g)}return u}catch(h){l.error=h,l.hasError=!0}finally{E(l)}}function tt(p,t,s,e,m,o,i,r,n,u,a,l=Number.NaN,h=Number.NaN){let _={stack:[],error:void 0,hasError:!1};try{if(i-o<r)return u;let c=v(_,new k(new x,new x),!1),f=new y,g=new y,d=new y;g.setNAN(),n||a.getPointCount()>0&&(g.setCoordsPoint2D(a.getXY(a.getPointCount()-1)),g.scale(s));let C=Math.ceil(o/r),P=C++*r;P===o&&(P=C++*r);let D=o,b=1/s;for(;P<i+r&&(D<l&&l<P?(P=l,C--):D<h&&h<P&&(P=h,C--),!(P>=i));)S.geodesicCoordinate(p,t,m.x,m.y,e,P,c.at(0),c.at(1)),n?d.setCoords(c.at(0).val,c.at(1).val):(f.setCoords(c.at(0).val,c.at(1).val),u=ee(m.x,f.x,g.x,u),d.setCoords(u+f.x,f.y),g.setCoordsPoint2D(d)),d.scale(b),a.insertPoint2D(0,-1,d),D=P,P=C++*r;return u}catch(c){_.error=c,_.hasError=!0}finally{E(_)}}function Zt(p,t,s,e,m,o,i,r,n,u,a){let l={stack:[],error:void 0,hasError:!1};try{let h=new y,_=new y,c=v(l,new k(new x,new x),!1);S.geodesicCoordinate(p,t,m.x,m.y,e,o,c.at(0),c.at(1)),h.setCoords(c.at(0).val,c.at(1).val),S.geodesicCoordinate(p,t,m.x,m.y,e,i,c.at(0),c.at(1)),_.setCoords(c.at(0).val,c.at(1).val);let f=v(l,new x,!1);for(S.geodeticDistance(p,t,r.x,r.y,h.x,h.y,null,f,null,0),u[0]=f.val,S.geodeticDistance(p,t,r.x,r.y,_.x,_.y,null,f,null,0),a[0]=f.val;u[0]<=a[0];)u[0]+=A;for(;u[0]>a[0];)u[0]-=A;for(;u[0]>=n;)u[0]-=A,a[0]-=A;for(;u[0]<n;)u[0]+=A,a[0]+=A}catch(h){l.error=h,l.hasError=!0}finally{E(l)}}function ee(p,t,s,e){if(Number.isNaN(s)){for(;e+t-p>Math.PI;)e-=A;for(;p-(e+t)>Math.PI;)e+=A;return e}return e+t-s>Math.PI?e-=A:s-(e+t)>Math.PI&&(e+=A),e}function me(p,t){let s=p.getGeometryType(),e;if(e=F(s)?p.getPathCount():s===T.enumMultiPoint?p.getPointCount():1,e===1)return p;let m=[],o=[];for(let r=0;r<e;r++){m.push(r);let n=new y;if(F(s)){let a=new G;p.queryPathEnvelope(r,a),n.assign(a.getCenter())}else n.assign(p.getXY(r));let u=t.toGeohash(n);o.push(u)}m.sort((r,n)=>o[r]<o[n]?-1:o[r]>o[n]?1:0);let i=p.createInstance();for(let r=0;r<e;r++){let n=m[r];F(s)?i.addPath(p,n,!0):i.addPoints(p,n,n+1)}return i}function se(p,t,s,e,m,o){let i={stack:[],error:void 0,hasError:!1};try{if(e>=o)return!1;let r=s[0],n=s.at(-1),u=v(i,new x,!1),a=v(i,new x,!1),l=v(i,new x,!1);S.greatEllipticDistance(p,t,m.x,m.y,r.x,r.y,u,null,null),S.greatEllipticDistance(p,t,m.x,m.y,n.x,n.y,a,null,null),S.greatEllipticDistance(p,t,r.x,r.y,n.x,n.y,l,null,null);let h=Math.min(u.val,a.val)+l.val,_=h+e;if(_<o)return!0;let c=v(i,new x,!1);h=Math.max(u.val,a.val);for(let f=1;f<s.length-1;f++){let g=s[f];S.greatEllipticDistance(p,t,m.x,m.y,g.x,g.y,c,null,null),c.val>h&&(h=c.val)}return _=h+e,_<o}catch(r){i.error=r,i.hasError=!0}finally{E(i)}}function $t(p,t,s,e,m,o,i,r){let n;if(e.length%2==0){let l=e.length>>1,h=e[l],_=e[l-1];n=y.lerp(h,_,.5)}else n=e[e.length-1>>1].clone();let u=n.clone(),a=Z(p,t,u,75/180*Math.PI);return!!se(p,t,e,m,u,a)&&(o!==null&&(o.setCoordsPoint2D(n),o.scale(1/s)),i!==null&&i.setCoordsPoint2D(u),r!==null&&(r[0]=a),!0)}function ne(p,t,s,e,m,o){let i={stack:[],error:void 0,hasError:!1};try{if(e>=o)return!1;let r=v(i,new x,!1);return S.greatEllipticDistance(p,t,m.x,m.y,s.x,s.y,r,null,null),r.val+e<o}catch(r){i.error=r,i.hasError=!0}finally{E(i)}}function ae(p,t,s,e,m,o,i,r){let n=Z(p,t,e,.4166666666666667*Math.PI);return!!ne(p,t,e,m,e,n)&&(o!==null&&(o.setCoordsPoint2D(e),o.scale(1/s)),i!==null&&i.setCoordsPoint2D(e),r!==null&&(r[0]=n),!0)}function et(p,t){return new jt(p,t)}function ht(p){return Xt(p,0)||Yt(p,0),p}var ct=class{constructor(t){this.m_bRunningInGnomonic=!1,this.m_bNeedsSimplify=!1,this.m_gnomonic=null,this.m_gnomonicCenterRad=new y,this.m_minGnomonicRadius=Number.NaN,this.m_progressTracker=t}isRunningInGnomonic(){return this.m_bRunningInGnomonic}needsSimplify(){return this.m_bNeedsSimplify}getGnomonic(){return this.m_gnomonic}},ut=class extends ct{constructor(t,s,e){super(t.m_progressTracker),this.m_segIter=null,this.m_bNextSegmentCannotJoin=!1,this.m_currentDensifiedDelta=[0],this.m_currentBufferedDelta=0,this.m_lastAzimuth=0,this.m_startAzimuth=[0],this.m_endAzimuth=[0],this.m_numWinds=0,this.m_debugCounter=0,this.m_bufferHelper=new N,this.m_densifiedPoints=[],this.m_bufferer=t,this.m_multiPath=s,this.m_densified=e,this.m_bNeedsSimplify=!0;let m=new G;this.m_multiPath.queryEnvelope(m);let o=m.getCenter(),i=o.clone();i.scale(this.m_bufferer.m_rpu),this.m_gnomonic=et(this.m_bufferer.m_gcs,o),this.m_gnomonicCenterRad=i.clone(),this.m_minGnomonicRadius=Z(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,i,75/180*Math.PI)}next(){let t;if(this.m_bNextSegmentCannotJoin)return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),t=this.m_bufferHelper.clone(),t;if(this.m_segIter===null){if(this.m_segIter=this.m_multiPath.getImpl().querySegmentIterator(),!this.m_segIter.nextPath())return null;this.m_densified!==null&&this.m_densified.addPathPoint2D(null,0,!0)}if(!this.m_segIter.hasNextSegment()){if(!this.m_segIter.nextPath())return null;this.m_densified!=null&&this.m_densified.addPathPoint2D(null,0,!0)}let s=null;this.m_currentBufferedDelta=0,this.m_currentDensifiedDelta=[0],this.m_numWinds=0,this.m_lastAzimuth=Number.NaN,this.m_bNextSegmentCannotJoin=!1,this.m_densifiedPoints.length=0;let e=16,m=0,o=new y,i=new y;for(;this.m_segIter.hasNextSegment()&&this.m_numWinds<e;){let r=this.m_segIter.nextSegment();if(o.setCoordsPoint2D(r.getStartXY()),i.setCoordsPoint2D(r.getEndXY()),o.scale(this.m_bufferer.m_rpu),i.scale(this.m_bufferer.m_rpu),K(o,i))o.x=i.x;else if(Q(o,i))i.x=o.x;else{let u=-1,a=-1,l=this.m_segIter.getPathIndex(),h=this.m_multiPath.getPathStart(l),_=this.m_multiPath.getPathEnd(l);if(u=this.m_segIter.getStartPointIndex()-1,a=this.m_segIter.getEndPointIndex()+1,u<h&&(u=this.m_multiPath.isClosedPath(l)?_-1:-1),a>_-1&&(a=this.m_multiPath.isClosedPath(l)?h:-1),u!==-1){let c=this.m_multiPath.getXY(u);c.scale(this.m_bufferer.m_rpu),Q(c,o)&&(o.x=c.x)}if(a!==-1){let c=this.m_multiPath.getXY(a);c.scale(this.m_bufferer.m_rpu),K(i,c)&&(i.x=c.x)}}this.m_densifiedPoints.length=0;let n=xt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,o,i,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta);if(m===0)this.m_bRunningInGnomonic=this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(this.m_densifiedPoints));else if(this.m_bRunningInGnomonic){if(!this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}}else if($t(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_densifiedPoints,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,null,null,null)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}if(n===0||Jt(o,i)?(this.m_bufferHelper.setEmpty(),this.m_bufferer.bufferPoint2D(o,this.m_bRunningInGnomonic,this.m_bufferHelper),this.m_bNextSegmentCannotJoin=!0):(this.m_bufferHelper.setEmpty(),this.m_bNextSegmentCannotJoin=this.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(n,this.m_bufferHelper)),this.m_bNextSegmentCannotJoin){this.m_segIter.previousSegment(),this.m_segIter.hasPreviousSegment()?(this.m_segIter.previousSegment(),this.m_segIter.nextSegment()):this.m_segIter.resetToFirstSegment(),this.m_densified!=null&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0);break}this.m_densified!=null&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0),s===null&&(s=new N,s.addPathPoint2D(null,0,!0)),this.addJoinAndBufferLeftSide(s),m++}if(this.m_currentDensifiedDelta=[0],m>0){let r=this.m_segIter.getStartPointIndex(),n=this.m_segIter.getPathIndex();for(;m>0;){if(this.m_segIter.previousSegment(),o.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),i.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getEndPointIndex())),o.scale(this.m_bufferer.m_rpu),i.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic)if(K(o,i))o.x=i.x;else if(Q(o,i))i.x=o.x;else{let u=-1,a=-1,l=this.m_segIter.getPathIndex(),h=this.m_multiPath.getPathStart(l),_=this.m_multiPath.getPathEnd(l);if(u=this.m_segIter.getStartPointIndex()-1,a=this.m_segIter.getEndPointIndex()+1,u<h&&(u=this.m_multiPath.isClosedPath(l)?_-1:-1),a>_-1&&(a=this.m_multiPath.isClosedPath(l)?h:-1),u!==-1){let c=this.m_multiPath.getXY(u);c.scale(this.m_bufferer.m_rpu),Q(c,o)&&(o.x=c.x)}if(a!==-1){let c=this.m_multiPath.getXY(a);c.scale(this.m_bufferer.m_rpu),K(i,c)&&(i.x=c.x)}}this.m_densifiedPoints.length=0,xt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,i,o,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta),this.addJoinAndBufferLeftSide(s),m--}return o.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),o.scale(this.m_bufferer.m_rpu),this.m_currentBufferedDelta=tt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,o,this.m_lastAzimuth+.5*Math.PI,this.m_lastAzimuth+1.5*Math.PI,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,s),this.m_segIter.resetToVertex(r,n),this.m_segIter.nextSegment(),s}return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),t=this.m_bufferHelper.clone(),t}isSegmentBufferInCurrentGnomonic(t){return this.m_gnomonic!==null&&se(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(t){let s=new y,e=new y,m=[0];return $t(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,s,e,m)?(this.m_gnomonicCenterRad.setCoordsPoint2D(e),this.m_minGnomonicRadius=m[0],this.m_gnomonic=et(this.m_bufferer.m_gcs,s),!0):(this.m_gnomonic=null,!1)}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(t,s){return this.m_bufferer.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(this.m_densifiedPoints,t,this.m_startAzimuth[0],this.m_endAzimuth[0],this.m_bRunningInGnomonic,s)}addJoinAndBufferLeftSide(t){let s=this.m_densifiedPoints[0],e=Number.NaN,m=this.m_startAzimuth[0]-O,o=this.m_endAzimuth[0]+O,i=!1;if(!Number.isNaN(this.m_lastAzimuth)){this.m_lastAzimuth>=this.m_startAzimuth[0]?(e=this.m_lastAzimuth+O,m=e+Math.PI-(this.m_lastAzimuth-this.m_startAzimuth[0])):(e=this.m_lastAzimuth+O,m=e+Math.PI-(A-(this.m_startAzimuth[0]-this.m_lastAzimuth))),i=!(this.m_lastAzimuth>=this.m_startAzimuth[0]&&this.m_lastAzimuth-this.m_startAzimuth[0]<=Math.PI)&&!(this.m_lastAzimuth<this.m_startAzimuth[0]&&this.m_startAzimuth[0]-this.m_lastAzimuth>=Math.PI);let r=!1;if(Math.abs(m-e)<=.5*this.m_bufferer.m_cornerStep&&(i||(r=!0)),r){if(t.removePointFromPath(0,t.getPointCount()-1),!this.m_bRunningInGnomonic){let n=new y;n.setCoordsPoint2D(t.getXY(t.getPointCount()-1)),n.scale(this.m_bufferer.m_rpu),n.x-this.m_currentBufferedDelta<-Math.PI?this.m_currentBufferedDelta-=A:n.x-this.m_currentBufferedDelta>Math.PI&&(this.m_currentBufferedDelta+=A)}m=.5*(m+e)}else if(i){let n=new y;n.setCoordsPoint2D(s),n.scale(1/this.m_bufferer.m_rpu),t.insertPoint2D(0,-1,n)}else tt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_densifiedPoints[0],e,m,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t)}this.m_startAzimuth[0]!==this.m_lastAzimuth&&this.m_numWinds++,Ct(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_bufferer.m_curveType,this.m_densifiedPoints,m,o,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t),this.m_lastAzimuth=this.m_endAzimuth[0]}},vt=class extends ct{constructor(t,s){super(t.m_progressTracker),this.m_pointIndex=-1,this.m_bufferer=t,this.m_multiPoint=s,this.m_bNeedsSimplify=!1;let e=new G;this.m_multiPoint.queryEnvelope(e);let m=e.getCenter(),o=m.clone();o.scale(this.m_bufferer.m_rpu),this.m_gnomonic=et(this.m_bufferer.m_gcs,m),this.m_gnomonicCenterRad=o.clone(),this.m_minGnomonicRadius=Z(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,o,75/180*Math.PI)}next(){if(this.m_bNeedsSimplify=!1,++this.m_pointIndex===this.m_multiPoint.getPointCount())return null;let t=this.m_multiPoint.getXY(this.m_pointIndex);t.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic=this.isPointBufferInCurrentGnomonic(t),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(t));let s=new N,e=this.m_bufferer.bufferPoint2D(t,this.m_bRunningInGnomonic,s);return this.m_bNeedsSimplify=e,s}isPointBufferInCurrentGnomonic(t){return this.m_gnomonic!==null&&ne(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(t){let s=new y,e=new y,m=[0];return ae(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,s,e,m)?(this.m_gnomonicCenterRad.setCoordsPoint2D(e),this.m_minGnomonicRadius=m[0],this.m_gnomonic=et(this.m_bufferer.m_gcs,s),!0):(this.m_gnomonic=null,!1)}},te=class{getOperatorType(){return 10110}supportsCurves(){return!0}accelerateGeometry(t,s,e){return!1}canAccelerateGeometry(t){return!1}executeMany(t,s,e,m,o,i,r,n){if(r){let u=new lt(t,s,e,m,o,!1,i,n);return new j().executeMany(u,s,n)}return new lt(t,s,e,m,o,!1,i,n)}execute(t,s,e,m,o,i,r){let n=new Mt([t]),u=[m],a=this.executeMany(n,s,e,u,o,!1,i,r).next();return a||Rt("geodesic buffer null output"),a}},lt=class extends Gt{constructor(t,s,e,m,o,i,r,n){super(),this.m_currentUnionEnvelope2D=new G,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=n,i&&qt(""),s||it(""),s.getCoordinateSystemType()===0&&it(""),this.m_inputGeoms=t,this.m_spatialReference=s,this.m_curveType=e,this.m_distances=m,this.m_convergenceOffset=o,this.m_bOutlineOnly=i,this.m_bUnion=r}next(){let t;for(;t=this.m_inputGeoms.next();)return ft(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.geodesicBuffer(t,this.m_distances[this.m_dindex]);return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodesicBuffer(t,s){return oe(t,this.m_spatialReference,this.m_curveType,s,this.m_convergenceOffset,this.m_progressTracker)}};export{te as OperatorGeodesicBuffer};
