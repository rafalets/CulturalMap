import{A as f,C as M,L as v,M as p,N as _,O as X,a as h,s as a,w as G}from"./chunk-UNRRVLTB.js";import{a as P,b as d}from"./chunk-6DVIB4O4.js";import{b as i,g as c,o as y,x as s,y as m}from"./chunk-JLMESEWM.js";var x=class{getOperatorType(){return 10102}supportsCurves(){return!1}accelerateGeometry(r,u,n){return!1}canAccelerateGeometry(r){return!1}executeMany(r,u,n){return new C(u,r,n)}execute(r,u){return Y(r)}isConvex(r,u){if(s(r),m(r),r.isEmpty())return!0;let n=r.getGeometryType();if(n===i.enumPoint)return!0;if(n===i.enumEnvelope){let o=r;return o.getXMin()!==o.getXMax()&&o.getYMin()!==o.getYMax()}if(c(n)){let o=r;return!o.getStartXY().equals(o.getEndXY())}if(n===i.enumMultiPoint)return r.getPointCount()===1;if(n===i.enumPolyline){let o=r;return o.getPathCount()===1&&o.getPointCount()===2&&!o.getXY(0).equals(o.getXY(1))}if(n===i.enumGeometryCollection){let o=r;return o.getGeometryCount()===1&&this.isConvex(o.getGeometry(0),u)}let t=r;return!(t.getPathCount()!==1||t.getPointCount()<3)&&p(t,0)}constructOrientedMinimumBoundingBox(r,u,n,t,o){_(r,u,n,t,o)}},C=class extends P{constructor(r,u,n){super(),u||y(""),this.m_progressTracker=n,this.m_index=-1,this.m_bMerge=r,this.m_bDone=!1,this.m_inputGeometryCursor=u}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}next(){if(this.m_bMerge){if(!this.m_bDone){let r=E(this.m_inputGeometryCursor);return this.m_bDone=!0,r}return null}if(!this.m_bDone){let r=this.m_inputGeometryCursor.next();if(r!==null)return s(r),m(r),this.m_index=this.m_inputGeometryCursor.getGeometryID(),Y(r);this.m_bDone=!0}return null}};function E(e,r){let u=new X,n;for(;n=e.next();)s(n),m(n),u.addGeometry(n);return u.getBoundingGeometry()}function Y(e,r){if(e||y(""),s(e),m(e),e.isEmpty())return e.createInstance();let u=e.getGeometryType();if(c(u)){let n=e;if(n.getStartXY().equals(n.getEndXY())){let t=new a;return n.queryStart(t),t}{let t=new a,o=new f({vd:e.getDescription()});return n.queryStart(t),o.startPathPoint(t),n.queryEnd(t),o.lineToPoint(t),o}}if(u===i.enumEnvelope){let n=e,t=new h;if(n.queryEnvelope(t),t.xmin===t.xmax&&t.ymin===t.ymax){let o=new a;return n.queryCornerByVal(0,o),o}if(t.xmin===t.xmax||t.ymin===t.ymax){let o=new a,l=new f({vd:e.getDescription()});return n.queryCornerByVal(0,o),l.startPathPoint(o),n.queryCornerByVal(1,o),l.lineToPoint(o),l}{let o=new M({vd:e.getDescription()});return o.addEnvelope(n,!1),o}}if(u===i.enumGeometryCollection)return E(G(e,-1));if(w(e)){if(u===i.enumMultiPoint){let n=e,t=new a;return n.getPointByVal(0,t),t}return e}return v(e)}function w(e,r){if(s(e),m(e),e.isEmpty())return!0;let u=e.getGeometryType();if(u===i.enumPoint)return!0;if(u===i.enumEnvelope){let t=e;return t.getXMin()!==t.getXMax()&&t.getYMin()!==t.getYMax()}if(c(u)){let t=e;return!t.getStartXY().equals(t.getEndXY())}if(u===i.enumMultiPoint)return e.getPointCount()===1;if(u===i.enumPolyline){let t=e;return t.getPathCount()===1&&t.getPointCount()===2&&!t.getXY(0).equals(t.getXY(1))}if(u===i.enumGeometryCollection){let t=e;return t.getGeometryCount()===1&&w(t.getGeometry(0))}let n=e;return!(n.getPathCount()!==1||n.getPointCount()<3)&&p(n,0)}var g=new x;function S(e){return g.execute(e,null)}function O(e,r){let u=g.executeMany(new d(e),r,null);return Array.from(u)}function V(e){return g.isConvex(e,null)}function k(){return g.supportsCurves()}export{S as a,O as b,V as c,k as d};
