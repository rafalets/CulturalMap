import{a as Ke,b as ee}from"./chunk-LVSL2E7G.js";import{a as U,b as C,c as We,e as Ce,f as Ge,g as Ve,h as je,i as Ze,j as Ne,k as qe,l as Ye,m as Xe,n as He,o as Qe,p as J,q as K,r as Ue,s as $e,t as Je,u as tt}from"./chunk-7VDGAO6V.js";import{b as Fe}from"./chunk-RW7NPOAD.js";import{d as et}from"./chunk-WSIRBPY7.js";import{D as W,a as O,d as Oe,z as Me}from"./chunk-BKA6DT3N.js";import{a as b}from"./chunk-WH5SLVE3.js";import{g as ve}from"./chunk-ET5YWLZA.js";import{k as Re,l as Be}from"./chunk-WQQ6B254.js";import{a as xe}from"./chunk-JXEAVWUK.js";import{n as fe,t as De}from"./chunk-3ZANJLLA.js";import{a as H}from"./chunk-4E4FE2IX.js";import{a as G}from"./chunk-4D3QHJI2.js";import{g as _e,h as $}from"./chunk-E2J2V7JN.js";import{G as Y,M as X}from"./chunk-X7BNFUFQ.js";import{b as q}from"./chunk-37H4LYIE.js";import{h as z}from"./chunk-HM5RIVQC.js";import{a as B}from"./chunk-2FO7ARYZ.js";import{b as D,c as Ee,g as pe,n as Q,s as ge,y as ye}from"./chunk-QXXXCEV5.js";import{a as Te}from"./chunk-IJBTA53P.js";import{a as ze}from"./chunk-J5MXC6AL.js";import{a as S}from"./chunk-OLOKUDVI.js";import{d as Se}from"./chunk-WMHJC7XF.js";import{b as ke,r as Ie,t as Le}from"./chunk-HHDFN2GK.js";import{t as N}from"./chunk-47GHT6OF.js";import{a as E,b as T,f as L,i as A}from"./chunk-VTHXE323.js";var te=class extends Ce{};function st(a){let{sprite:e,isMapAligned:t,colorLocked:r,scaleSymbolsProportionally:s,isStroke:o}=a,i=0;return t&&(i|=C(O.bitset.isMapAligned)),r&&(i|=C(O.bitset.colorLocked)),e.sdf&&(i|=C(O.bitset.isSDF)),s&&(i|=C(O.bitset.scaleSymbolsProportionally)),o&&(i|=C(O.bitset.isStroke)),i}var se=class extends te{get vertexSpec(){return{createComputedParams:e=>{let{pixelDimensions:t,texelDimensions:r,baseSize:s,referenceSize:o,strokeWidth:i,sizeRatio:n}=e;t||(t=e.sprite.sdf?[0,0]:[e.sprite.width,e.sprite.height]),r||(r=e.sprite.sdf?[0,0]:t),s=S(s),o=S(o),i=S(i);let c=(e.sprite.sdfDecodeCoeff??1)*n;return T(E({},e),{pixelDimensions:t,texelDimensions:r,baseSize:s,referenceSize:o,strokeWidth:i,sdfDecodeCoeff:c})},optionalAttributes:{zoomRange:{type:z.SHORT,count:2,packPrecisionFactor:X,pack:({scaleInfo:e},{tileInfo:t})=>U(e,t)}},attributes:{id:{type:z.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:z.UNSIGNED_BYTE,count:1,pack:st},pos:{type:z.SHORT,count:2,pack:"position",packPrecisionFactor:1},offset:{type:z.FLOAT,count:2,packAlternating:{count:4,pack:e=>{let t=e.texelDimensions;return[[-.5*t[0],-.5*t[1]],[.5*t[0],-.5*t[1]],[-.5*t[0],.5*t[1]],[.5*t[0],.5*t[1]]]}}},uv:{type:z.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:e,texXmin:t,texYmax:r,texYmin:s})=>[[t,s],[e,s],[t,r],[e,r]]}},animationPointerAndBaseSizeAndReferenceSize:{type:z.UNSIGNED_SHORT,count:4,packPrecisionFactor:1,pack:({animations:e,baseSize:t,referenceSize:r})=>[e.dataColumn,e.dataRow,t,r]},sizing:{type:z.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:e,pixelDimensions:t,baseSize:r,sprite:s,sizeRatio:o})=>{let i=Math.max(r*s.width/s.height,r),n=s.sdfDecodeCoeff*i*o;return[t[0],t[1],e,n]}},angle:{type:z.BYTE,count:1,packTessellation:({angle:e})=>e}}}}_write(e,t){let r=this.evaluatedMeshParams.sprite,{textureBinding:s}=r;e.recordStart(this.instanceId,this.attributeLayout,s);let o=t.getDisplayId();if(t.geometryType==="esriGeometryPolygon"){let i=t.readCentroidForDisplay();if(!i)return;let[n,c]=i.coords;this._writeQuad(e,o,n,c)}else if(t.geometryType==="esriGeometryPoint"){let i=t.readXForDisplay(),n=t.readYForDisplay();this._writeQuad(e,o,i,n)}else{let i=t.readGeometryForDisplay();if(i){let{angleToLine:n}=this.evaluatedMeshParams;if(n){let c=!0,m=null,u=null;i.forEachVertex((l,h)=>{if(m!=null&&u!=null){let p=Math.atan2(h-u,l-m)/Oe;c&&(this._writeQuad(e,o,m,u,p),c=!1),this._writeQuad(e,o,l,h,p)}m=l,u=h})}else i.forEachVertex((c,m)=>{this._writeQuad(e,o,c,m)})}}e.recordEnd()}_writeQuad(e,t,r,s,o=0){let i=this.evaluatedMeshParams.sprite,{rect:n}=i,c=n.x+Y,m=n.y+Y,u=n.x+n.width-Y,l=n.y+n.height-Y,h=e.vertexCount();e.recordBounds(r,s,64,64);let p={texXmin:c,texYmin:m,texXmax:u,texYmax:l,angle:o};for(let g=0;g<4;g++)this._writeVertex(e,t,r,s,p);e.indexEnsureSize(6),e.indexWrite(h),e.indexWrite(h+1),e.indexWrite(h+2),e.indexWrite(h+1),e.indexWrite(h+3),e.indexWrite(h+2)}};function rt(a,e,t){return a[0]=e[0]-t[0],a[1]=e[1]-t[1],a}function ot(a,e){return Math.sqrt(a*a+e*e)}function it(a){let e=ot(a[0],a[1]);a[0]/=e,a[1]/=e}function ft(a,e){return ot(a[0]-e[0],a[1]-e[1])}function pt(a,e){return a[e+1]}function at(a){return a.length-1}function gt(a){let e=0;for(let t=0;t<at(a);t++)e+=yt(a,t);return e}function yt(a,e,t=1){let[r,s]=pt(a,e);return[r,s]=[Math.round(r),Math.round(s)],Math.sqrt(r*r+s*s)*t}var Pe=class a{constructor(e,t,r,s,o){this._segments=e,this._index=t,this._distance=r,this._xStart=s,this._yStart=o,this._done=!1}static create(e){return new a(e,0,0,e[0][0],e[0][1])}clone(){return new a(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(e){return this._index===e._index||e._index===this._index-1&&(this._distance===0||e._distance===1)||e._index===this._index+1&&(this._distance===1||e._distance===0)}leq(e){return this._index<e._index||this._index===e._index&&this._distance<=e._distance}geq(e){return this._index>e._index||this._index===e._index&&this._distance>=e._distance}get _segment(){return this._segments[this._index+1]}get angle(){let e=this.dy,t=(0*e+-1*-this.dx)/(1*this.length),r=Math.acos(t);return e>0&&(r=2*Math.PI-r),r}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){let{dx:e,dy:t}=this;return Math.sqrt(e*e+t*t)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<at(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(e,t){let r=this.backwardLength;if(e<=r)return this._distance=(r-e)/this.length,this;let s=this.backwardLength;for(;this.prev();){if(s+this.length>e)return this._seekBackwards(e-s);s+=this.length}return this._distance=0,t?this:null}seek(e,t=!1){if(e<0)return this._seekBackwards(Math.abs(e),t);if(e<=this.remainingLength)return this._distance=(this.backwardLength+e)/this.length,this;let r=this.remainingLength;for(;this.next();){if(r+this.length>e)return this.seek(e-r,t);r+=this.length}return this._distance=1,t?this:null}};function ie(a,e,t,r=!0){let s=gt(a),o=Pe.create(a),i=s/2;if(!r)return o.seek(i),void(Math.abs(o.x)<1024&&Math.abs(o.y)<1024&&t(o.clone(),0,i+0*e,s));let n=Math.max((s-e)/2,0),c=Math.floor(n/e),m=i-c*e;o.seek(m);for(let u=-c;u<=c;u++)Math.abs(o.x)<1024&&Math.abs(o.y)<1024&&t(o.clone(),u,i+u*e,s),o.seek(e)}function oe(a,e){let t=e;for(let r=0;r<a.length;r++){let s=a[r];_t(s,t);let o=[];o.push(s[0]);for(let i=1;i<s.length;i++){let[n,c]=s[i-1],[m,u]=s[i],l=m-n,h=u-c;o.push([l,h])}a[r]=o,s=o}return a}function _t(a,e){if(e<=0)return;let r=a.length;if(r<3)return;let s=[],o=0;s.push(0);for(let l=1;l<r;l++)o+=ft(a[l],a[l-1]),s.push(o);e=Math.min(e,.2*o);let i=[];i.push(a[0][0]),i.push(a[0][1]);let n=a[r-1][0],c=a[r-1][1],m=rt([0,0],a[0],a[1]);it(m),a[0][0]+=e*m[0],a[0][1]+=e*m[1],rt(m,a[r-1],a[r-2]),it(m),a[r-1][0]+=e*m[0],a[r-1][1]+=e*m[1];for(let l=1;l<r;l++)s[l]+=e;s[r-1]+=e;let u=.5*e;for(let l=1;l<r-1;l++){let h=0,p=0,g=0;for(let d=l-1;d>=0&&!(s[d+1]<s[l]-u);d--){let f=u+s[d+1]-s[l],y=s[d+1]-s[d],_=s[l]-s[d]<u?1:f/y;if(Math.abs(_)<1e-6)break;let M=_*_,x=_*f-.5*M*y,v=_*y/e,P=a[d+1],I=a[d][0]-P[0],R=a[d][1]-P[1];h+=v/x*(P[0]*_*f+.5*M*(f*I-y*P[0])-M*_*y*I/3),p+=v/x*(P[1]*_*f+.5*M*(f*R-y*P[1])-M*_*y*R/3),g+=v}for(let d=l+1;d<r&&!(s[d-1]>s[l]+u);d++){let f=u-s[d-1]+s[l],y=s[d]-s[d-1],_=s[d]-s[l]<u?1:f/y;if(Math.abs(_)<1e-6)break;let M=_*_,x=_*f-.5*M*y,v=_*y/e,P=a[d-1],I=a[d][0]-P[0],R=a[d][1]-P[1];h+=v/x*(P[0]*_*f+.5*M*(f*I-y*P[0])-M*_*y*I/3),p+=v/x*(P[1]*_*f+.5*M*(f*R-y*P[1])-M*_*y*R/3),g+=v}i.push(h/g),i.push(p/g)}i.push(n),i.push(c);for(let l=0,h=0;l<r;l++)a[l][0]=i[h++],a[l][1]=i[h++]}var ae=1,V=0,xt=128,Mt=Se(a=>{let e=0;if(a===0)return 1/0;for(;!(a%2);)e++,a/=2;return e}),ne=class extends K{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,r,s){if(this._zoomLevel=s||0,r!=null)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{let o=t.readXForDisplay(),i=t.readYForDisplay();this._writePoint(e,o,i,t);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":case"esriGeometryMultipoint":{let o=t.readCentroidForDisplay();if(!o)return;let[i,n]=o.coords;this._writePoint(e,i,n,t);break}case"esriGeometryPolyline":this._writeLines(e,t)}}_getMetricDir(){let{horizontalAlignment:e,verticalAlignment:t}=this.evaluatedMeshParams;return[e==="center"?0:e==="right"?-1:1,t==="middle"?0:t==="bottom"?-1:1]}_createLineLabelMetric(e,t,r,s){let o=Me(e),[i,n]=this._getMetricDir(),c=this.evaluatedMeshParams.scaleInfo?.maxScale??0,m=this.evaluatedMeshParams.scaleInfo?.minScale??0;return new ve(o,t,r,i,n,c,m,s??null)}_writePoint(e,t,r,s){let o=this._getShaping();if(!o)return;let i=s.getDisplayId(),n=Re(this.evaluatedMeshParams.horizontalAlignment),c=Be(this.evaluatedMeshParams.verticalAlignment),m=this.evaluatedMeshParams.scaleInfo?.maxScale??0,u=this.evaluatedMeshParams.scaleInfo?.minScale??0,l=Me(s.getDisplayId()),h=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new ve(l,t,r,n,c,m,u,h)),this._writeGlyphs(e,i,t,r,o,0,h),e.metricBoxWrite(o.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(let e of this._references){let t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){let{scaleInfo:r,verticalAlignment:s}=this.evaluatedMeshParams,o=this.evaluatedMeshParams.repeatLabelDistance||128,i=this._getShaping("middle");if(!i)return;let n=(m,u,l,h)=>this._placeSubdivGlyphs(m,u,l,h),c=(i.bounds.width+o)/(1<<ae);this._current={out:e,id:t.getDisplayId(),shaping:i,zoomRange:U(r,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null},this._verticalPlacement=s==="bottom"?"above":s==="top"?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,n,c):this._writeCenterAlong(t,n,c)}_writeAboveAndBelowAlong(e,t,r){let{repeatLabel:s}=this.evaluatedMeshParams,{shaping:o}=this._current,i=o.bounds.halfHeight,n=e.readGeometryForDisplay();if(!n)return;let c=new H;De(c,n,!1,!1,"esriGeometryPolyline",1);let m=nt(new H,c,i),u=nt(new H,c,-i),l=fe(u,"esriGeometryPolyline",!1,!1),h=fe(m,"esriGeometryPolyline",!1,!1),p=oe(h.paths,o.bounds.width),g=oe(l.paths,o.bounds.width);this._current.offsetDirection="above";for(let d of p)ie(d,r,t,!!s);this._current.offsetDirection="below";for(let d of g)ie(d,r,t,!!s)}_writeCenterAlong(e,t,r){let{repeatLabel:s}=this.evaluatedMeshParams,{shaping:o}=this._current,i=oe(e.readLegacyGeometryForDisplay().paths,o.bounds.width);for(let n of i)ie(n,r,t,!!s)}_placeSubdivGlyphs(e,t,r,s){let{allowOverrun:o,labelPosition:i,repeatLabelDistance:n}=this.evaluatedMeshParams,c=this._current.zoomRange[0],m=Mt(t),u=this._current.shaping.bounds.width/(1<<ae),l=Math.sqrt(n||xt)/(1<<ae),h=Math.min(r,s-r),p=this._current.shaping.isMultiline?J:Math.log2(h/(l+u/2)),g=t===0?p:Math.min(m,p),d=Math.max(c,this._zoomLevel+ae-g),f=this._zoomLevel-d,y=this._current.shaping.bounds.width/2*2**f;this._current.shaping.isMultiline?t===0&&this._placeStraight(e,d):o&&f<0?this._placeStraightAlong(e,c):i==="parallel"?this._placeStraightAlong(e,d):i==="curved"&&this._placeCurved(e,d,y)}_placeStraight(e,t){let{out:r,id:s,shaping:o,referenceBounds:i}=this._current,{x:n,y:c}=e;r.metricStart(this._createLineLabelMetric(s,n,c)),r.metricBoxWrite(o.boundsT);let m=e.angle*(180/Math.PI)%360,u=(e.angle*(180/Math.PI)+180)%360;this._writeGlyphs(r,s,n,c,o,0,i,{clipAngle:m,mapAligned:!0,isLineLabel:!0,minZoom:t}),this._writeGlyphs(r,s,n,c,o,0,i,{clipAngle:u,mapAligned:!0,isLineLabel:!0,minZoom:t}),r.metricEnd()}_placeCurved(e,t,r){let{out:s,id:o}=this._current;s.metricStart(this._createLineLabelMetric(o,e.x,e.y));let i=e.clone(),n=e.angle*(180/Math.PI)%360,c=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(i,t,1,n),this._placeBack(e,i,t,r,1,n),this._placeForward(e,i,t,r,1,n)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(i,t,0,c),this._placeBack(e,i,t,r,0,c),this._placeForward(e,i,t,r,0,c)),s.metricEnd()}_placeStraightAlong(e,t){let{out:r,id:s,shaping:o,zoomRange:i,referenceBounds:n}=this._current,{boxBorderLineColor:c,boxBackgroundColor:m}=this.evaluatedMeshParams,u=e.clone(),l=e.angle*(180/Math.PI)%360,h=(e.angle*(180/Math.PI)+180)%360,p=o.glyphs.length>0&&!(!c&&!m);if(r.metricStart(this._createLineLabelMetric(s,e.x,e.y)),p){let g=Math.max(t,i[0],0),d=Math.min(J,i[1]),f=$(G(),-e.angle),y={minZoom:g,maxZoom:d,clipAngle:l,mapAligned:!0,isLineLabel:!0},_=S(this.evaluatedMeshParams.offsetX),M=S(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){let x=q(_,-1*M),[v,P]=o.shapeBackground(_e(G(),f,x));r.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding);let I=2*Math.max(v.width,v.height);r.recordBounds(e.x+v.x,e.y+v.y,I,I),this._writeTextBox(r,s,e.x,e.y,P,n,y),r.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){let x=q(_,M),[v,P]=o.shapeBackground(_e(G(),f,x));y.clipAngle=h,r.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding);let I=2*Math.max(v.width,v.height);r.recordBounds(e.x+v.x,e.y+v.y,I,I),this._writeTextBox(r,s,e.x,e.y,P,n,y),r.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(u,t,1,l,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(u,t,0,h,!0),r.metricEnd()}_placeBack(e,t,r,s,o,i){let n=e.clone(),c=e.backwardLength+V;for(;n.prev()&&!(c>=s);)this._placeOnSegment(n,t,c,r,-1,o,i),c+=n.length+V}_placeForward(e,t,r,s,o,i){let n=e.clone(),c=e.remainingLength+V;for(;n.next()&&!(c>=s);)this._placeOnSegment(n,t,c,r,1,o,i),c+=n.length+V}_placeFirst(e,t,r,s,o=!1){let{out:i,id:n,shaping:c,zoomRange:m,referenceBounds:u}=this._current,l=c.glyphs,h=S(this.evaluatedMeshParams.offsetX),p=S(this.evaluatedMeshParams.offsetY),g=q(h,p),d=$(G(),-e.angle);ge(g,g,d);for(let f of l){let y=f.x>c.bounds.x?r:1-r,_=y*e.remainingLength+(1-y)*e.backwardLength,M=Math.abs(f.x+f.width/2-c.bounds.x),x=Math.max(0,this._zoomLevel+Math.log2(M/(_+V))),v=Math.max(t,o?0:x);if(f.maxZoom=Math.min(m[1],J),f.angle=e.angle+(1-r)*Math.PI,f.minZoom=Math.max(m[0],v),this._writeLineGlyph(i,n,e.x,e.y,c.bounds,f,s,u,!0),(r||this._current.offsetDirection)&&this._isVisible(f.minZoom,f.maxZoom)){let P=new xe(f.bounds.x+g[0],f.bounds.y+g[1],f.bounds.width,f.bounds.height);i.metricBoxWrite(P)}}}_placeOnSegment(e,t,r,s,o,i,n){let{out:c,id:m,shaping:u,referenceBounds:l}=this._current,h=u.glyphs,p=e.dx/e.length,g=e.dy/e.length,d={x:e.x+r*-o*p,y:e.y+r*-o*g},f=S(this.evaluatedMeshParams.offsetX),y=S(this.evaluatedMeshParams.offsetY),_=q(f,y),M=$(G(),-e.angle);ge(_,_,M);for(let x of h){let v=x.x>u.bounds.x?i:1-i;if(!(v&&o===1||!v&&o===-1))continue;let P=Math.abs(x.x+x.width/2-u.bounds.x),I=Math.max(0,this._zoomLevel+Math.log2(P/r)-.1),R=Math.max(s,this._zoomLevel+Math.log2(P/(r+e.length+V)));if(I!==0&&(x.angle=e.angle+(1-i)*Math.PI,x.minZoom=R,x.maxZoom=I,this._writeLineGlyph(c,m,d.x,d.y,u.bounds,x,n,l,!0),(i||this._current.offsetDirection)&&this._isVisible(x.minZoom,x.maxZoom))){let dt=new xe(x.bounds.x+_[0],x.bounds.y+_[1],x.bounds.width,x.bounds.height);c.metricBoxWrite(dt)}}}_writeLineGlyph(e,t,r,s,o,i,n,c,m){let u=r+o.x,l=s+o.y,h=2*(this.evaluatedMeshParams.minPixelBuffer?this.evaluatedMeshParams.minPixelBuffer/this._textMeshTransformProps.fontSize:1),p=Math.max(o.width,o.height)*h;e.recordStart(this.instanceId,this.attributeLayout,i.textureBinding),e.recordBounds(u,l,p,p);let{texcoords:g,offsets:d}=i,{fontSize:f,haloSize:y,outlineSize:_}=this._textMeshTransformProps;this._writeQuad(e,t,r,s,{texcoords:g,offsets:d,fontSize:f,haloSize:y,outlineSize:_,color:We(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:c,minZoom:Math.max(this._current.zoomRange[0],i.minZoom),maxZoom:Math.min(this._current.zoomRange[1],i.maxZoom),clipAngle:n,mapAligned:m,isLineLabel:!0}),e.recordEnd()}_isVisible(e,t){let r=Math.floor(this._zoomLevel*X)/X;return e<=r&&r<=t}};function nt(a,e,t){let{coords:r,lengths:s}=e,o=B(),i=B(),n=B(),c=B(),m=B(),u=B(),l=2,h=0;for(let p=0;p<s.length;p++){let g=s[p];for(let d=0;d<g;d++){let f=l*(d+h-1),y=l*(d+h),_=l*(d+h+1);d>0?D(o,r[f],r[f+1]):D(o,0,0),D(i,r[y],r[y+1]),d<g-1?D(n,r[_],r[_+1]):D(n,0,0),d===0?D(c,0,0):(ye(c,i,o),Q(c,c),D(c,c[1],-c[0])),d===g-1?D(m,0,0):(ye(m,n,i),Q(m,m),D(m,m[1],-m[0])),Ee(u,c,m),Q(u,u);let M=u[0]*m[0]+u[1]*m[1];M!==0&&pe(u,u,M),pe(u,u,t),a.coords.push(i[0]+u[0],i[1]+u[1])}a.lengths.push(g),h+=g}return a}function Z(a){return a instanceof j?a:typeof a=="object"&&"type"in a?vt[a.type].hydrate(a):new F(a)}var j=class{constructor(e){this.inputs=e}encode(){let e=[];for(let t of this.inputs)e.push(...t.encode());return e.push(...this.instructions),e}},F=class extends j{constructor(e){super([]),this.value=e}simplify(){return this}get instructions(){if(Array.isArray(this.value)){let[e,t,r,s]=this.value;return s!=null?W.vector4.encode([e,t||0,r||0,s]):W.vector3.encode([e,t||0,r||0])}return W.scalar.encode(this.value)}},be=class a extends j{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new a(e,Z(e.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;let e=this._parent.simplify();if(!(e instanceof F))return this;let[t,r,s,o]=e.value,i=this._config.translation.from[0],n=this._config.translation.from[1],c=this._config.rotation.from,m=this._config.scale.from;if(i===this._config.translation.to[0]&&n===this._config.translation.to[1]&&c===this._config.rotation.to&&m===this._config.scale.to){let u=s+c,l=o*m,h=Math.sin(s),p=Math.cos(s);return new F([p*o*i-h*o*n+t,h*o*i+p*o*n+r,u,l])}return new a(this._config,e)}get instructions(){return W.animatedTransform.encode(this._config)}},we=class a extends j{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new a(e,Z(e.parent))}simplify(){let e=this._parent.simplify();if(!(e instanceof F))return this;let[t,r,s,o]=e.value,i=this._config.color.from[0],n=this._config.color.from[1],c=this._config.color.from[2],m=this._config.color.from[3],u=this._config.opacity.from;return i===this._config.color.to[0]&&n===this._config.color.to[1]&&c===this._config.color.to[2]&&m===this._config.color.to[3]&&u===this._config.opacity.to?(m*=u,new F([t*i,r*n,s*c,o*m])):new a(this._config,e)}get instructions(){return W.animatedColor.encode(this._config)}},vt={AnimatedTransform:be,AnimatedColor:we};function ct(a){return Ae(a.map(e=>w(e)).map(e=>Z(e).simplify()))}function lt(a){let e=[];return e.push(a.transform),e.push(a.fromColor),e.push(a.toColor),e.push(a.colorMix),e.push(a.toOpacity),e.push(a.opacityMix),e}function Ae(a){let e=[],t=[],r=0;for(let s of a){let o=[...s.encode(),...W.ret.encode()];e.push([r+a.length,0,0,0]),t.push(...o),r+=o.length}return[...e,...t]}function le(a,e){return L(this,null,function*(){let t=a,r;if(typeof t=="number"||typeof t=="string"||typeof t=="boolean")r=t;else if(Array.isArray(t))r=yield Promise.all(t.map(s=>le(s,e)));else if(typeof t=="object")if("valueExpressionInfo"in t){let{valueExpressionInfo:s}=t,{expression:o}=s;r=T(E({},t),{computed:yield e.createComputedField({expression:o})})}else{r={};for(let s in t)r[s]=yield le(t[s],e)}return r})}function w(a,e,t){function r(i){if(!("computed"in i))return i;let n=i.computed.readWithDefault(e,t,[255*i.defaultValue[0],255*i.defaultValue[1],255*i.defaultValue[2],i.defaultValue[3]]);if(typeof n=="string"){let c=ze.fromString(n);c&&(n=[c.r,c.g,c.b,c.a])}return n}let s=a,o;if(typeof s=="number"||typeof s=="string"||typeof s=="boolean")o=s;else if(Array.isArray(s))o=s.map(i=>w(i,e,t));else if(typeof s=="object")if("type"in s&&s.type!=null&&s.type==="Process")switch(s.op){case"ArcadeColor":{let i=w(s.value,e,t);ce(Array.isArray(i)&&i.length===4),o=[i[0]/255,i[1]/255,i[2]/255,i[3]]}break;case"Transparency":{let i=w(s.value,e,t);ce(typeof i=="number"),o=1-i/100}break;case"Divide":case"Add":{let i=w(s.left,e,t);ce(typeof i=="number");let n=w(s.right,e,t);switch(ce(typeof n=="number"),s.op){case"Divide":o=i/n;break;case"Add":o=i+n}}break;case"Random":{let i=w(s.seed,e,t),n=w(s.min,e,t),c=w(s.max,e,t),m=e.getObjectId(),u=ee(m||0);o=n+Ke(u,i)*(c-n)}break;case"Cond":{let i=w(s.condition,e,t),n=w(s.ifTrue,e,t),c=w(s.ifFalse,e,t);o=i?n:c}break;case"MatchWinding":{let i=w(s.sign,e,t),n=w(s.angle,e,t);if(i>0)for(;n<0;)n+=2*Math.PI;else for(;n>0;)n-=2*Math.PI;o=n}}else if("computed"in s)o=r(s);else{o={};for(let i in s)o[i]=w(s[i],e,t)}return o}function*k(a){let e=a;if(Array.isArray(e))for(let t of e)yield*A(k(t));else if(typeof e=="object")if("type"in e&&e.type!=null&&e.type==="Process")switch(e.op){case"ArcadeColor":case"Transparency":yield*A(k(e.value));break;case"Divide":case"Add":yield*A(k(e.left)),yield*A(k(e.right));break;case"Random":yield*A(k(e.seed)),yield*A(k(e.min)),yield*A(k(e.max));break;case"Cond":yield*A(k(e.condition)),yield*A(k(e.ifTrue)),yield*A(k(e.ifFalse));break;case"MatchWinding":yield*A(k(e.sign)),yield*A(k(e.angle))}else if("computed"in e)yield e.computed;else for(let t in e)yield*A(k(e[t]))}function ce(a){if(!a)throw new Error("Assertion failed.")}var he=class extends et{constructor(e){super(),this._value=e}resize(e){}read(e,t){return this._value}readWithDefault(e,t,r){return this._value}hasArcadeDependency(e){return!1}};var Pt=()=>Ie.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");function me(a,e,t=!1){return L(this,null,function*(){let{defaultValue:r,valueExpressionInfo:s,value:o}=e;if(s){let{expression:i}=s,n=yield a.createComputedField({expression:i},t);return n?T(E({},e),{computed:n,defaultValue:r}):null}return T(E({},e),{computed:new he(o),defaultValue:r})})}function ht(a,e){return L(this,null,function*(){let{valueExpressionInfo:t}=e,{expression:r}=t,s=yield a.createComputedField({expression:r});return s?T(E({},e),{computed:s}):null})}function mt(a){return typeof a=="object"&&a!=null&&(!(!("valueExpressionInfo"in a)||!a.valueExpressionInfo)||"type"in a&&a.type==="Process"&&"op"in a&&a.op==="Random")}function ue(a){if(Array.isArray(a)){for(let e of a)if(ue(e))return!0}if(typeof a=="object"){if(mt(a))return!0;for(let e in a)if(ue(a[e]))return!0}return!1}var de=class a{static create(e,t,r){return L(this,null,function*(){let s={},o=new Map,i=new Map,n=new Map,c=new Map,m=new Map,u=new Map;for(let l in r){let h=r[l];if(h!=null&&typeof h=="object")if(Array.isArray(h)){if(typeof h[0]=="object")throw new Error(`InternalError: Cannot handle ${l}. Nested array params are not supported`);s[l]=h}else if("valueExpressionInfo"in h){if(h.value){s[l]=h.value;continue}let p=yield ht(e,h);if(!p){s[l]=h.defaultValue;continue}o.set(l,p),s[l]=null}else switch(h.type){case"cim-effect-infos":if(h.effectInfos.some(p=>p.overrides.length)){i.set(l,{effects:yield Promise.all(h.effectInfos.map(p=>L(this,null,function*(){let g=p.overrides.map(d=>me(e,d));return{effect:p.effect,compiledOverrides:(yield Promise.all(g)).filter(N)}})))});break}s[l]=h.effectInfos.map(p=>p.effect);break;case"cim-marker-placement-param":h.overrides.length&&n.set(l,{placementInfo:h,compiledOverrides:(yield Promise.all(h.overrides.map(p=>me(e,p)))).filter(N)}),s[l]=h.placement;break;case"text-rasterization-param":{if(h.overrides.length){let g=h.overrides.map(d=>me(e,d,h.useLegacyLabelEvaluationRules));c.set(l,{compiledOverrides:(yield Promise.all(g)).filter(N),rasterizationParam:h,objectIdToResourceId:new Map});continue}let p={type:"cim-rasterization-info",resource:h.resource};s[l]=(yield t.fetchResourceImmediate(p))??null;break}case"sprite-rasterization-param":{if(h.overrides.length){let g=h.overrides.map(d=>me(e,d));c.set(l,{compiledOverrides:(yield Promise.all(g)).filter(N),rasterizationParam:h,objectIdToResourceId:new Map});continue}if(h.resource.type==="animated"){c.set(l,{compiledOverrides:[],rasterizationParam:h,objectIdToResourceId:new Map});continue}let p={type:"cim-rasterization-info",resource:h.resource};s[l]=(yield t.fetchResourceImmediate(p))??null;break}case"cim-marker-transform-param":{let{params:p}=h;if(ue(p)){let g={compiledMarkerInfos:[]};yield Promise.all(p.map(d=>L(this,null,function*(){let f={props:{}};for(let y in d)if(mt(d[y])){let _=yield ht(e,d[y]);f.compiledExpressionMap||(f.compiledExpressionMap=new Map);let M=f.compiledExpressionMap;_&&M.set(y,_)}else f.props[y]=d[y];g.compiledMarkerInfos.push(f)}))),m.set(l,g)}else s[l]={type:"cim-marker-transform-info",infos:p};break}case"animation-params":{let{params:p}=h,g=lt(p);if(ue(g)){let d=yield Promise.all(g.map(f=>le(f,e)));u.set(l,{params:d,propertyIdToResourceId:new Map,key:l})}else{let d=ct(g),f=yield t.fetchResourceImmediate({type:"animation-info",resource:d});f!=null&&f.type==="sprite"&&(s[l]={dataRow:f.rect.y,dataColumn:f.rect.x})}break}default:s[l]=h}else s[l]=h}return new a(r,s,o,i,n,c,m,u)})}constructor(e,t,r,s,o,i,n,c){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=r,this._dynamicEffectProperties=s,this._dynamicPlacementProperties=o,this._dynamicAsyncProperties=i,this._dynamicTransformProperties=n,this._dynamicAsyncAnimations=c,this.evaluator=m=>m,this._arcadeDependencies=new Set;for(let m of this._expressions())Te(this._arcadeDependencies,m)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,r){for(let s of this._dynamicAsyncProperties.values()){let o=ke(s.rasterizationParam.resource);s.rasterizationParam.resource.type==="animated"&&s.rasterizationParam.resource.randomizeStartTime&&(o.primitiveName="__RESERVED__PRIMITIVE__NAME__",o.startGroup=ee(t.getObjectId()||0));for(let{primitiveName:n,propertyName:c,computed:m,defaultValue:u,valueExpressionInfo:l}of s.compiledOverrides)try{let h=s.rasterizationParam.resource.type==="animated"?o.primitiveName:n;Fe(o,h,c,m,t,r,u)}catch(h){Pt().errorOnce(new Le("invalid-arcade-expression",`Encountered an error when evaluating the arcade expression '${l?.expression}' (primitive: '${n}', property: '${c}')`,h))}let i=e.enqueueRequest({type:"cim-rasterization-info",resource:o});s.objectIdToResourceId.set(t.getObjectId(),i)}for(let s of this._dynamicAsyncAnimations.values()){let o=s.params.map(c=>w(c,t,r)).map(Z).map(c=>c.simplify()),i=Ae(o),n=e.enqueueRequest({type:"animation-info",resource:i});s.propertyIdToResourceId.set(t.getObjectId()+"."+s.key,n)}}evaluateMeshParams(e,t,r){for(let[s,o]of this._dynamicProperties.entries())this._resolvedMeshParams[s]=o.computed.readWithDefault(t,r,o.defaultValue);for(let[s,o]of this._dynamicPlacementProperties.entries())for(let{computed:i,defaultValue:n,propertyName:c}of o.compiledOverrides){let m=i.readWithDefault(t,r,n);o.placementInfo.placement[c]=m,this._resolvedMeshParams[s]=o.placementInfo.placement}for(let[s,o]of this._dynamicEffectProperties.entries())for(let i of o.effects){for(let{computed:n,defaultValue:c,propertyName:m}of i.compiledOverrides){let u=n.readWithDefault(t,r,c);i.effect[m]=u}this._resolvedMeshParams[s]=o.effects.map(n=>n.effect)}for(let[s,o]of this._dynamicTransformProperties.entries()){let i={type:"cim-marker-transform-info",infos:[]};for(let n of o.compiledMarkerInfos){let c=E({},n.props);if(n.compiledExpressionMap)for(let[m,u]of n.compiledExpressionMap){let l=u.computed.readWithDefault(t,r,u.defaultValue);c[m]=typeof l=="number"||typeof l=="boolean"?l:u.defaultValue}i.infos.push(c)}this._resolvedMeshParams[s]=i}for(let[s,o]of this._dynamicAsyncProperties.entries()){let i=o.objectIdToResourceId.get(t.getObjectId());if(i==null)continue;let n=e.getResource(i);this._resolvedMeshParams[s]=n}for(let[s,o]of this._dynamicAsyncAnimations.entries()){let i=o.propertyIdToResourceId.get(t.getObjectId()+"."+s);if(i==null)continue;let n=e.getResource(i);this._resolvedMeshParams[s]={dataRow:n.rect.y,dataColumn:n.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(e){return this._arcadeDependencies.has(e)}*_expressions(){for(let e of this._dynamicProperties.values())yield e.computed;for(let e of this._dynamicEffectProperties.values())for(let t of e.effects)for(let r of t.compiledOverrides)yield r.computed;for(let e of this._dynamicPlacementProperties.values())for(let t of e.compiledOverrides)yield t.computed;for(let e of this._dynamicAsyncProperties.values())for(let t of e.compiledOverrides)yield t.computed;for(let e of this._dynamicTransformProperties.values())for(let t of e.compiledMarkerInfos)if(t.compiledExpressionMap!=null)for(let r of t.compiledExpressionMap.values())yield r.computed;for(let e of this._dynamicAsyncAnimations.values())for(let t of e.params)yield*A(k(t))}};var ut=class{createMeshWriter(e,t,r,s){return L(this,null,function*(){let o=this._getMeshWriter(s.techniqueType),i=yield de.create(e,t,s.inputParams),n=new o(s.id,i,s.optionalAttributes,r);return yield n.loadDependencies(),n})}_getMeshWriter(e){switch(e){case b.Fill:return Ve;case b.DotDensity:return Ge;case b.ComplexFill:return Ze;case b.PatternFill:return je;case b.GradientFill:return Xe;case b.OutlineFill:return qe;case b.PatternOutlineFill:return He;case b.ComplexOutlineFill:return Ye;case b.Marker:return Je;case b.PieChart:return tt;case b.Text:return K;case b.Line:return Ne;case b.TexturedLine:return $e;case b.GradientStroke:return Ue;case b.Heatmap:return Qe;case b.Label:return ne;case b.AnimatedMarker:return se;default:throw new Error("Internal Error: Mesh writer not in the registry")}}};export{he as a,ut as b};
