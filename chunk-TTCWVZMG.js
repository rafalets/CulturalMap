import{g as y}from"./chunk-5SSISWTF.js";import{c,f as R}from"./chunk-BUZBVNOM.js";import{e as n,h as _,r as h,v as f}from"./chunk-HM5RIVQC.js";import{j as g}from"./chunk-D2LVMNOU.js";import{r as o}from"./chunk-HHDFN2GK.js";import{A as d,C as E,k as x,x as A}from"./chunk-47GHT6OF.js";import{f as b}from"./chunk-VTHXE323.js";var B=()=>o.getLogger("esri.views.webgl.BufferObject");var m=class r{static createIndex(e,t,i){return new r(e,n.ELEMENT_ARRAY_BUFFER,t,i)}static createVertex(e,t,i){return new r(e,n.ARRAY_BUFFER,t,i)}static createUniform(e,t,i){return new r(e,n.UNIFORM_BUFFER,t,i)}static createPixelPack(e,t=h.STREAM_READ,i){let s=new r(e,n.PIXEL_PACK_BUFFER,t);return i&&s.setSize(i),s}static createPixelUnpack(e,t=h.STREAM_DRAW,i){return new r(e,n.PIXEL_UNPACK_BUFFER,t,i)}static createTransformFeedback(e,t=h.STATIC_DRAW,i){let s=new r(e,n.TRANSFORM_FEEDBACK_BUFFER,t);return s.setSize(i),s}constructor(e,t,i,s){this._context=e,this.bufferType=t,this.usage=i,this._glName=null,this._size=-1,this._indexType=void 0,e.instanceCounter.increment(f.BufferObject,this),this._glName=this._context.gl.createBuffer(),c(this._context.gl),s&&this.setData(s)}get glName(){return this._glName}get size(){return this._size}get indexType(){return this._indexType}get usedMemory(){if(this.bufferType===n.ELEMENT_ARRAY_BUFFER){if(this._indexType===_.UNSIGNED_INT)return 4*this._size;if(this._indexType===_.UNSIGNED_SHORT)return 2*this._size}return this._size}get _isVAOAware(){return this.bufferType===n.ELEMENT_ARRAY_BUFFER||this.bufferType===n.ARRAY_BUFFER}dispose(){this._context?.gl?(this._glName&&(this._context.gl.deleteBuffer(this._glName),this._glName=null),this._context.instanceCounter.decrement(f.BufferObject,this),this._context=null):this._glName&&B().warn("Leaked WebGL buffer object")}setSize(e,t=null){if(this.bufferType===n.ELEMENT_ARRAY_BUFFER&&t!=null)switch(this._indexType=t,t){case _.UNSIGNED_SHORT:e*=2;break;case _.UNSIGNED_INT:e*=4}this._setBufferData(e)}setData(e){if(!e)return;let t=e.byteLength;this.bufferType===n.ELEMENT_ARRAY_BUFFER&&(A(e)?this._indexType=_.UNSIGNED_BYTE:d(e)?(t/=2,this._indexType=_.UNSIGNED_SHORT):E(e)&&(t/=4,this._indexType=_.UNSIGNED_INT)),this._setBufferData(t,e)}_setBufferData(e,t=null){this._size=e;let i=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);let s=this._context.gl;t!=null?s.bufferData(this.bufferType,t,this.usage):s.bufferData(this.bufferType,e,this.usage),c(s),this._isVAOAware&&this._context.bindVAO(i)}setSubData(e,t,i,s){if(!e)return;let u=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);let{gl:a}=this._context;a.bufferSubData(this.bufferType,t*e.BYTES_PER_ELEMENT,e,i,s-i),c(a),this._isVAOAware&&this._context.bindVAO(u)}getSubData(e,t=0,i,s){if(i<0||s<0)return;let u=T(e)?e.BYTES_PER_ELEMENT:1;if(u*((i??0)+(s??0))>e.byteLength)return;t+u*(s??0)>this.usedMemory&&B().warn("Potential problem getting subdata: requested data exceeds buffer size!");let a=this._context.gl;this.bufferType===n.TRANSFORM_FEEDBACK_BUFFER?(this._context.bindBuffer(this,n.TRANSFORM_FEEDBACK_BUFFER),a.getBufferSubData(n.TRANSFORM_FEEDBACK_BUFFER,t,e,i,s),this._context.unbindBuffer(n.TRANSFORM_FEEDBACK_BUFFER)):(this._context.bindBuffer(this,n.COPY_READ_BUFFER),a.getBufferSubData(n.COPY_READ_BUFFER,t,e,i,s),this._context.unbindBuffer(n.COPY_READ_BUFFER))}getSubDataAsync(e,t=0,i,s){return b(this,null,function*(){yield this._context.clientWaitAsync(),this.getSubData(e,t,i,s)})}};function T(r){return x(r)}var l=()=>o.getLogger("esri.views.webgl.VertexArrayObject"),I=class{constructor(r,e,t,i,s=null){this._context=r,this._locations=e,this._layout=t,this._buffers=i,this._indexBuffer=s,this._glName=null,this._initialized=!1}get glName(){return this._glName}get context(){return this._context}get vertexBuffers(){return this._buffers}get indexBuffer(){return this._indexBuffer}get byteSize(){return Array.from(this._buffers.values()).reduce((r,e)=>r+e.usedMemory,this._indexBuffer!=null?this._indexBuffer.usedMemory:0)}get layout(){return this._layout}get locations(){return this._locations}get usedMemory(){return this.byteSize+(this._buffers.size+(this._indexBuffer?1:0))*y}get cachedMemory(){return this.usedMemory}dispose(){this._context?(this._context.getBoundVAO()===this&&this._context.bindVAO(null),this._buffers.forEach(r=>r.dispose()),this._buffers.clear(),this._indexBuffer=g(this._indexBuffer),this.disposeVAOOnly()):(this._glName||this._buffers.size>0)&&l().warn("Leaked WebGL VAO")}disposeVAOOnly(){this._glName&&(this._context.gl.deleteVertexArray(this._glName),this._glName=null,this._context.instanceCounter.decrement(f.VertexArrayObject,this)),this._context=null}initialize(){if(this._initialized)return;let{gl:r}=this._context,e=r.createVertexArray();r.bindVertexArray(e),this._bindLayout(),r.bindVertexArray(null),this._glName=e,this._context.instanceCounter.increment(f.VertexArrayObject,this),this._initialized=!0}bind(){this.initialize(),this._context.gl.bindVertexArray(this.glName)}_bindLayout(){let{_buffers:r,_layout:e,_indexBuffer:t}=this;r||l().error("Vertex buffer dictionary is empty!");let i=this._context.gl;this._buffers.forEach((s,u)=>{let a=e.get(u);a?R(this._context,this._locations,s,a):l().error("Vertex element descriptor is empty!")}),t!=null&&i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,t.glName)}unbind(){this.initialize(),this._context.gl.bindVertexArray(null)}};export{m as a,I as b};
