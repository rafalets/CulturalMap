import{a as P}from"./chunk-TTCWVZMG.js";import{a as O,d as l,h as M,k as T}from"./chunk-BUZBVNOM.js";import{e as D,m as u,n as R,p as C,q as f,r as B,t as d,v as m,w as o,y as F}from"./chunk-HM5RIVQC.js";import{j as A}from"./chunk-D2LVMNOU.js";import{r as g}from"./chunk-HHDFN2GK.js";import{f as N}from"./chunk-VTHXE323.js";var w=class{constructor(e,t,i=t){this.internalFormat=e,this.width=t,this.height=i,this.multisampled=!1,this.samples=1}};function U(r){return r.width<=0||r.height<=0||r.internalFormat==null?0:r.width*r.height*M(r.internalFormat)}var p=class{constructor(e,t){this._context=e,this._descriptor=t,this.type=l.RenderBuffer,this._context.instanceCounter.increment(m.Renderbuffer,this);let i=this._context.gl;this.glName=i.createRenderbuffer(),this._context.bindRenderbuffer(this);let{width:s,height:n,internalFormat:a,multisampled:h}=t;h?i.renderbufferStorageMultisample(i.RENDERBUFFER,this.samples,a,s,n):i.renderbufferStorage(i.RENDERBUFFER,a,s,n),this._context.bindRenderbuffer(null)}get descriptor(){return this._descriptor}get samples(){let e=this._descriptor.samples,t=this._context.parameters.maxSamples;return e?Math.min(e,t):t}get usedMemory(){return U(this._descriptor)}resize(e,t){let i=this._descriptor;if(i.width===e&&i.height===t)return;i.width=e,i.height=t;let s=this._context.gl;this._context.bindRenderbuffer(this),i.multisampled?s.renderbufferStorageMultisample(s.RENDERBUFFER,this.samples,i.internalFormat,i.width,i.height):s.renderbufferStorage(s.RENDERBUFFER,i.internalFormat,i.width,i.height),this._context.bindRenderbuffer(null)}dispose(){this._context&&(this._context.gl.deleteRenderbuffer(this.glName),this._context.instanceCounter.decrement(m.Renderbuffer,this),this._context=null)}};var y=()=>g.getLogger("esri.views.webgl.FramebufferObject"),S=class r{constructor(e,t,i=null){this._context=e,this._glName=null,this._colorAttachments=new Map,this._depthStencilBuffer=null,this._depthStencilTexture=null,this._initialized=!1,e.instanceCounter.increment(m.FramebufferObject,this);let s=E(t)?t:new T(this._context,t);if(this._colorAttachments.set(o.COLOR_ATTACHMENT0,s),this._validateTextureDescriptor(s.descriptor),this._validateColorAttachmentPoint(o.COLOR_ATTACHMENT0),i!=null)if(z(i))this._depthStencilTexture=E(i)?i:new T(this._context,i),this._validateTextureDescriptor(this._depthStencilTexture.descriptor);else{let n=H(i)?i:new p(this._context,i);this._depthStencilBuffer=n,this._validateRenderBufferDescriptor(n.descriptor)}}dispose(){if(this._colorAttachments.size===0&&!this._glName)return;let e=this._context.getBoundFramebufferObject();this._colorAttachments.forEach((t,i)=>this.detachColorTexture(i)?.dispose()),this.detachDepthStencilBuffer()?.dispose(),this.detachDepthStencilTexture()?.dispose(),this._glName&&(this._context.gl.deleteFramebuffer(this._glName),this._glName=null),this._context.bindFramebuffer(e),this._context.instanceCounter.decrement(m.FramebufferObject,this)}get glName(){return this._glName}get colorTexture(){return this._colorAttachments.get(o.COLOR_ATTACHMENT0)}get depthStencil(){return this._depthStencilTexture||this._depthStencilBuffer}get depthStencilTexture(){return this._depthStencilTexture}get width(){return this._colorAttachments.get(o.COLOR_ATTACHMENT0)?.descriptor?.width??0}get height(){return this._colorAttachments.get(o.COLOR_ATTACHMENT0)?.descriptor?.height??0}get usedMemory(){return[...this._colorAttachments].reduce((e,[t,i])=>e+i.usedMemory,this.depthStencil?.usedMemory??0)}getColorTexture(e){let t=this._colorAttachments.get(e);return t&&E(t)?t:null}get colorAttachments(){return[...this._colorAttachments.keys()]}attachColorTexture(e,t=o.COLOR_ATTACHMENT0){if(!e)return;this._validateColorAttachmentPoint(t);let i=e.descriptor;this._validateTextureDescriptor(i),this.detachColorTexture(t)?.dispose(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(e.glName,t)),this._colorAttachments.set(t,e)}detachColorTexture(e=o.COLOR_ATTACHMENT0){let t=this._colorAttachments.get(e);if(t){if(this._initialized){let i=this._context.getBoundFramebufferObject();this._context.bindFramebuffer(this),this._framebufferTexture2D(null,e),this._context.bindFramebuffer(i)}return this._colorAttachments.delete(e),t}}setColorTextureTarget(e,t=o.COLOR_ATTACHMENT0){let i=this._colorAttachments.get(t);i&&this._framebufferTexture2D(i.glName,t,e)}attachDepthStencil(e){if(e)switch(e.type){case l.Texture:return this._attachDepthStencilTexture(e);case l.RenderBuffer:return this._attachDepthStencilBuffer(e)}}_attachDepthStencilTexture(e){if(e==null)return;let t=e.descriptor;t.pixelFormat!==R.DEPTH_STENCIL&&t.pixelFormat!==R.DEPTH24_STENCIL8&&console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!"),t.dataType!==C.UNSIGNED_INT_24_8&&console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!"),this._validateTextureDescriptor(t),this._disposeDepthStencilAttachments(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(e.glName,F)),this._depthStencilTexture?.dispose(),this._depthStencilTexture=e}detachDepthStencilTexture(){let e=this._depthStencilTexture;if(e&&this._initialized){let t=this._context.getBoundFramebufferObject();this._context.bindFramebuffer(this),this._framebufferTexture2D(null,F),this._context.bindFramebuffer(t)}return this._depthStencilTexture=null,e}_attachDepthStencilBuffer(e){if(e==null)return;let t=e.descriptor;if(this._validateRenderBufferDescriptor(t),this._disposeDepthStencilAttachments(),this._initialized){this._context.bindFramebuffer(this);let i=this._context.gl,s=this._getGLAttachmentPoint(t);i.framebufferRenderbuffer(d.FRAMEBUFFER,s,i.RENDERBUFFER,e.glName)}this._depthStencilBuffer=e}detachDepthStencilBuffer(){let e=this._depthStencilBuffer;if(e&&this._initialized){let t=this._context.getBoundFramebufferObject();this._context.bindFramebuffer(this);let i=this._context.gl,s=this._getGLAttachmentPoint(e.descriptor);i.framebufferRenderbuffer(d.FRAMEBUFFER,s,i.RENDERBUFFER,null),this._context.bindFramebuffer(t)}return this._depthStencilBuffer=null,e}copyToTexture(e,t,i,s,n,a,h){(e<0||t<0||n<0||a<0)&&console.error("Offsets cannot be negative!"),(i<=0||s<=0)&&console.error("Copy width and height must be greater than zero!");let _=h.descriptor;h.descriptor.target!==u.TEXTURE_2D&&console.error("Texture target must be TEXTURE_2D!"),(_?.width==null||_?.height==null||e+i>this.width||t+s>this.height||n+i>_.width||a+s>_.height)&&console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");let c=this._context,b=c.bindTexture(h,T.TEXTURE_UNIT_FOR_UPDATES);c.setActiveTexture(T.TEXTURE_UNIT_FOR_UPDATES),c.bindFramebuffer(this),c.gl.copyTexSubImage2D(u.TEXTURE_2D,0,n,a,e,t,i,s),c.bindTexture(b,T.TEXTURE_UNIT_FOR_UPDATES)}readPixels(e,t,i,s,n,a,h){(i<=0||s<=0)&&console.error("Copy width and height must be greater than zero!"),h||console.error("Target memory is not initialized!"),this._context.bindFramebuffer(this),this._context.gl.readPixels(e,t,i,s,n,a,h)}readPixelsAsync(e,t,i,s,n,a,h){return N(this,null,function*(){let{gl:_}=this._context,c=P.createPixelPack(this._context,B.STREAM_READ,h.byteLength);this._context.bindBuffer(c);let b=this._context.getBoundFramebufferObject();this._context.bindFramebuffer(this),_.readPixels(e,t,i,s,n,a,0),this._context.unbindBuffer(D.PIXEL_PACK_BUFFER),this._context.bindFramebuffer(b),yield c.getSubDataAsync(h),c.dispose()})}resize(e,t){if(this.width===e&&this.height===t)return;let i={width:e,height:t};x(i,this._context.parameters.maxTextureSize),this._colorAttachments.forEach(s=>s.resize(i.width,i.height)),this._depthStencilTexture?.resize(i.width,i.height),this._initialized&&(x(i,this._context.parameters.maxRenderbufferSize),this._depthStencilBuffer?.resize(i.width,i.height),this._context.getBoundFramebufferObject()===this&&this._context.bindFramebuffer(null),this._initialized=!1)}initializeAndBind(e=d.FRAMEBUFFER){let t=this._context.gl;if(this._initialized)return void t.bindFramebuffer(e,this.glName);this._glName&&t.deleteFramebuffer(this._glName);let i=t.createFramebuffer();if(t.bindFramebuffer(e,i),this._colorAttachments.forEach((s,n)=>this._framebufferTexture2D(s.glName,n,L(s),e)),this._depthStencilBuffer){let s=this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);t.framebufferRenderbuffer(e,s,t.RENDERBUFFER,this._depthStencilBuffer.glName)}else this._depthStencilTexture&&this._framebufferTexture2D(this._depthStencilTexture.glName,t.DEPTH_STENCIL_ATTACHMENT,L(this._depthStencilTexture),e);O()&&t.checkFramebufferStatus(e)!==t.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer is incomplete!"),this._glName=i,this._initialized=!0}_framebufferTexture2D(e,t=o.COLOR_ATTACHMENT0,i=u.TEXTURE_2D,s=d.FRAMEBUFFER,n=0){this._context.gl.framebufferTexture2D(s,t,i,e,n)}_disposeDepthStencilAttachments(){let e=this._context.gl;if(this._depthStencilBuffer){if(this._initialized){this._context.bindFramebuffer(this);let t=this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);e.framebufferRenderbuffer(d.FRAMEBUFFER,t,e.RENDERBUFFER,null)}this._depthStencilBuffer=A(this._depthStencilBuffer)}this._depthStencilTexture&&(this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,e.DEPTH_STENCIL_ATTACHMENT)),this._depthStencilTexture=A(this._depthStencilTexture))}_validateTextureDescriptor(e){e.target!==u.TEXTURE_2D&&e.target!==u.TEXTURE_CUBE_MAP&&console.error("Texture type must be TEXTURE_2D or TEXTURE_CUBE_MAP!"),x(e,this._context.parameters.maxTextureSize),this._validateBufferDimensions(e)}_validateRenderBufferDescriptor(e){x(e,this._context.parameters.maxRenderbufferSize),this._validateBufferDimensions(e)}_validateBufferDimensions(e){e.width<=0&&(e.width=this.width),e.height<=0&&(e.height=this.height),this.width>0&&this.height>0&&(this.width===e.width&&this.height===e.height||console.error("Attachment size must match framebuffer size!"))}_getGLAttachmentPoint(e){switch(e.internalFormat){case f.DEPTH_COMPONENT16:case f.DEPTH_COMPONENT24:case f.DEPTH_COMPONENT32F:return this._context.gl.DEPTH_ATTACHMENT;case f.DEPTH24_STENCIL8:case f.DEPTH32F_STENCIL8:case f.DEPTH_STENCIL:return this._context.gl.DEPTH_STENCIL_ATTACHMENT;case f.STENCIL_INDEX8:return this._context.gl.STENCIL_ATTACHMENT}}_validateColorAttachmentPoint(e){if(r._MAX_COLOR_ATTACHMENTS===-1){let{gl:i}=this._context;r._MAX_COLOR_ATTACHMENTS=i.getParameter(i.MAX_COLOR_ATTACHMENTS)}let t=e-o.COLOR_ATTACHMENT0;t+1>r._MAX_COLOR_ATTACHMENTS&&g.getLogger("esri.views.webgl.FrameBufferObject").error("esri.FrameBufferObject",`illegal attachment point for color attachment: ${t+1}. Implementation supports up to ${r._MAX_COLOR_ATTACHMENTS} color attachments`)}};function E(r){return r!=null&&"type"in r&&r.type===l.Texture}function H(r){return r!=null&&"type"in r&&r.type===l.RenderBuffer}function z(r){return E(r)||r!=null&&"pixelFormat"in r}function x(r,e){let t=Math.max(r.width,r.height);if(t>e){y().warn(`Resizing FBO attachment size ${r.width}x${r.height} to device limit ${e}`);let i=e/t;return r.width=Math.round(r.width*i),r.height=Math.round(r.height*i),!1}return!0}function L(r){return r.descriptor.target===u.TEXTURE_CUBE_MAP?u.TEXTURE_CUBE_MAP_POSITIVE_X:u.TEXTURE_2D}S._MAX_COLOR_ATTACHMENTS=-1;export{w as a,p as b,S as c};
