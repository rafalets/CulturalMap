import{A as Y,C as z,D as V,n as Q}from"./chunk-UNRRVLTB.js";import{a as F,b as B}from"./chunk-6DVIB4O4.js";import{Ia as G,Ja as l,b as w,ca as K,da as N,g as H,o as D,s as J,tb as b,y as X}from"./chunk-JLMESEWM.js";function ot(a,t,i,n,s,o){if(a===null&&D(""),a.getDimension()<1&&D(""),s>0||D(""),X(a),t===0||a.isEmpty())return a;let h=new Z(o);return h.m_bUseZ=a.hasAttribute(1),h.m_bUseM=a.hasAttribute(2),h.m_inputGeometry=a,h.m_distance=t,h.m_tolerance=s,h.m_joins=i,h.m_miterLimit=n>1?n:1,h.m_progressCounter=0,h.constructOffset()}var O=1.4142135623730951,S=.017453292519943295,A=256,q=512,E=1024,M=class a{static construct(t,i,n){let s=new a;return s.x=t.x,s.y=t.y,s.m_next=-1,s.m_prev=-1,s.z=i,s.m=n,s.type=0,s}clone(){let t=new a;return t.x=this.x,t.y=this.y,t.m_next=this.m_next,t.m_prev=this.m_prev,t.z=this.z,t.m=this.m,t.type=this.type,t}asPoint2D(){return new b(this.x,this.y)}};function ht(){return{pt:new M,bAtExistingPt:!1}}var Z=class a{constructor(t){this.m_distance=-1,this.m_tolerance=-1,this.m_miterLimit=10,this.m_joins=0,this.m_progressCounter=0,this.m_bUseZ=!1,this.m_bUseM=!1,this.m_srcPts=[],this.m_srcPtCount=0,this.m_offsetPts=[],this.m_offsetPtCount=0,this.m_a1=0,this.m_a2=0,this.m_progressTracker=t}constructOffset(){let t=this.m_inputGeometry.getGeometryType();if(t===w.enumLine)return this.offsetLine();if(t===w.enumEnvelope)return this.offsetEnvelope();if(H(t)){let i=new Y;return i.addSegment(this.m_inputGeometry,!0),this.m_inputGeometry=i,this.constructOffset()}if(t===w.enumPolyline){let i=new Y;return this.offsetMultiPath(i),i}if(t===w.enumPolygon){let i=new z;return this.offsetMultiPath(i),i}J("")}offsetLine(){let t=this.m_inputGeometry,i=t.getStartXY(),n=t.getEndXY(),s=new b;s.setSub(n,i),s.normalize(),s.leftPerpendicularThis(),s.scale(this.m_distance),i.addThis(s),n.addThis(s);let o=t.clone();return o.setStartXY(i),o.setEndXY(n),o}offsetEnvelope(){let t=this.m_inputGeometry;if(this.m_distance>0&&this.m_joins!==2){let n=new z;return n.addEnvelope(t,!1),this.m_inputGeometry=n,this.constructOffset()}let i=t.clone();return i.inflateCoords(this.m_distance,this.m_distance),i}progress(){}static buildPoint(t,i,n,s){s.x=t.x+i*Math.cos(n),s.y=t.y+i*Math.sin(n),s.type=t.type,s.z=t.z,s.m=t.m,s.m_next=-1,s.m_prev=-1}addPoint(t){this.m_offsetPts.push(t.clone()),this.m_offsetPtCount++}addPointEx(t,i){if(this.m_offsetPtCount===0)return void this.addPoint(t);let n=this.m_srcPtCount,s=this.m_srcPts[i===0?n-1:i-1],o=this.m_srcPts[i],h=a.dotSign(s,o,this.m_offsetPts[this.m_offsetPtCount-1],t);if(h>0)this.addPoint(t);else if(h<0)if(a.dotSign(s,o,o,this.m_offsetPts[this.m_offsetPtCount-1])>0){let e=new M,m;m=i===0?n-2:i===1?n-1:i-2;let P=this.m_srcPts[m],_=Math.atan2(s.y-P.y,s.x-P.x);if(a.buildPoint(s,this.m_distance,_-l,e),this.m_offsetPts[this.m_offsetPtCount-1]=e,this.m_joins===1||this.m_joins===2){e.x=.5*(e.x+s.x),e.y=.5*(e.y+s.y),this.addPoint(e),a.buildPoint(s,this.m_distance,this.m_a1+l,e);let r=e.clone();r.x=.5*(r.x+s.x),r.y=.5*(r.y+s.y),r.type|=A,this.addPoint(r),this.addPoint(e)}else a.buildPoint(s,this.m_distance,this.m_a1+l,e),e.type|=A,this.addPoint(e);this.addPointEx(t,i)}else{let e=new M;if(a.buildPoint(o,this.m_distance,this.m_a1+l,e),this.addPoint(e),this.m_joins===1||this.m_joins===2){e.x=.5*(e.x+o.x),e.y=.5*(e.y+o.y),this.addPoint(e),a.buildPoint(o,this.m_distance,this.m_a2-l,e);let m=e.clone();m.x=.5*(m.x+o.x),m.y=.5*(m.y+o.y),m.type|=A,this.addPoint(m),this.addPoint(e)}else a.buildPoint(o,this.m_distance,this.m_a2-l,e),e.type|=A,this.addPoint(e)}}buildOffset(){let t=new M,i=this.m_srcPtCount;this.m_offsetPtCount=0;let n=.5*this.m_tolerance,s=0,o=0;for(let h=0;h<i;h++){let e=this.m_srcPts[h],m=h===0?this.m_srcPts[i-1]:this.m_srcPts[h-1],P=h===i-1?this.m_srcPts[0]:this.m_srcPts[h+1],_,r,p=0;{let c=m.x-e.x,f=m.y-e.y,d=P.x-e.x,u=P.y-e.y;_=Math.atan2(f,c),r=Math.atan2(u,d),this.m_a1=_,this.m_a2=r,h===0&&(s=_,o=r),p=b.orientationRobust(e.asPoint2D(),m.asPoint2D(),P.asPoint2D())}let g=r;if(r<_&&(r+=G),p*this.m_distance>0)if(this.m_joins===1||this.m_joins===2){a.buildPoint(e,this.m_distance,_+l,t),this.addPoint(t);let c=.001;t.x=e.x+(t.x-e.x)*c,t.y=e.y+(t.y-e.y)*c,this.addPoint(t),a.buildPoint(e,this.m_distance,r-l,t);let f=t.clone();f.x=e.x+(f.x-e.x)*c,f.y=e.y+(f.y-e.y)*c,f.type|=A,this.addPoint(f),this.addPoint(t)}else{let c=.5*(r-_),f=c===0?this.m_distance:this.m_distance/Math.abs(Math.sin(c));a.buildPoint(e,f,.5*(_+r),t),this.addPointEx(t,h)}else if(e.type&q){let c=1-n/Math.abs(this.m_distance),f=1,d=this.m_distance<0?-Math.PI:Math.PI;if(c>-1&&c<1){let x=2*Math.acos(c);x<S&&(x=S),f=Math.trunc(Math.PI/x+1.5),f>1&&(d/=f)}f<=1&&(f=2,d/=2);let u=_+l;a.buildPoint(e,this.m_distance,u,t),h===0&&(t.type|=E),this.addPointEx(t,h);let y=this.m_distance/Math.cos(d/2);for(u+=d/2,a.buildPoint(e,y,u,t),t.type|=E,this.addPoint(t);--f>0;)u+=d,a.buildPoint(e,y,u,t),t.type|=E,this.addPoint(t);a.buildPoint(e,this.m_distance,r-l,t),t.type|=E,this.addPoint(t)}else if(this.m_joins!==1)if(this.m_joins!==0)if(this.m_joins!==2){let c;if(r=g,this.m_distance>0?(r>_&&(r-=G),c=_-r<l):(r<_&&(r+=G),c=r-_<l),c){let f=this.m_distance*O,d;d=f<0?_+.25*Math.PI:_+3*Math.PI*.25,a.buildPoint(e,f,d,t),this.addPointEx(t,h),d=f<0?r-.25*Math.PI:r-3*Math.PI*.25,a.buildPoint(e,f,d,t),this.addPoint(t)}else{let f=.5*(r-_),d=this.m_distance/Math.abs(Math.sin(f));r<_&&(r+=G),a.buildPoint(e,d,(_+r)/2,t),this.addPointEx(t,h)}}else{let c=m.x-e.x,f=m.y-e.y,d=P.x-e.x,u=P.y-e.y,y=(c*d+f*u)/Math.sqrt(c*c+f*f)/Math.sqrt(d*d+u*u);if(y>1-1e-8){a.buildPoint(e,O*this.m_distance,r-.25*Math.PI,t),this.addPointEx(t,h),a.buildPoint(e,O*this.m_distance,r+.25*Math.PI,t),this.addPoint(t);continue}let x=Math.abs(this.m_distance/Math.sin(.5*Math.acos(y))),v=Math.abs(this.m_miterLimit*this.m_distance);if(x>v){let tt=.5*(r-_),st=this.m_distance/Math.abs(Math.sin(tt));a.buildPoint(e,st,.5*(_+r),t);let et=b.construct(t.x,t.y),R=b.construct(e.x,e.y),C=new b;C.setSub(et,R);let I=new b;I.setScaleAdd(v/C.length(),C,R);let it=Math.sqrt(x*x-this.m_distance*this.m_distance),nt=(x-v)*Math.abs(this.m_distance)/it;this.m_distance>0?C.leftPerpendicularThis():C.rightPerpendicularThis(),C.scale(nt/C.length());let j=new b;j.setAdd(I,C);let T=new b;T.setSub(I,C),t.x=j.x,t.y=j.y,this.addPointEx(t,h),t.x=T.x,t.y=T.y,this.addPoint(t);continue}let W=.5*(r-_),$=this.m_distance/Math.abs(Math.sin(W));a.buildPoint(e,$,.5*(_+r),t),this.addPointEx(t,h)}else{let c=1-n/Math.abs(this.m_distance),f=1,d=r-l-(_+l);if(c>-1&&c<1){let x=2*Math.acos(c);x<S&&(x=S),f=Math.trunc(Math.abs(d)/x+1.5),f>1&&(d/=f)}let u=this.m_distance/Math.cos(.5*d),y=_+l+.5*d;for(a.buildPoint(e,u,y,t),this.addPointEx(t,h);--f>0;)y+=d,a.buildPoint(e,u,y,t),this.addPoint(t)}else a.buildPoint(e,this.m_distance,_+l,t),this.addPointEx(t,h),a.buildPoint(e,this.m_distance,r-l,t),this.addPoint(t)}return this.m_a1=s,this.m_a2=o,this.addPointEx(this.m_offsetPts[0],0),this.m_offsetPts[0]=this.m_offsetPts[this.m_offsetPtCount-1].clone(),this.removeBadSegsFast()}removeBadSegsFast(){let t=!1;for(let n=0;n<this.m_offsetPtCount;n++){let s=this.m_offsetPts[n];s.m_next=n+1,s.m_prev=n-1}this.m_offsetPts[0].m_prev=this.m_offsetPtCount-2,this.m_offsetPts[this.m_offsetPtCount-2].m_next=0;let i=0;for(let n=0;n<this.m_offsetPtCount;n++)if(this.m_offsetPts[i].type&A){let s=this.deleteClosedSeg(i);if(s===-1){t=!0;break}i=s}else i=this.m_offsetPts[i].m_next;return!t&&(this.compressOffsetArray(i),!0)}deleteClosedSeg(t){let i=this.m_offsetPtCount-1,n,s,o=t;for(let h=1;h<=i-2;h++){o=this.m_offsetPts[o].m_next,n=o,s=t;for(let e=1;e<=h;e++){if(s=this.m_offsetPts[s].m_prev,!(this.m_offsetPts[s].type&A||this.m_offsetPts[n].type&A)){let m=this.handleClosedIntersection(s,n);if(m!==-1)return m}n=this.m_offsetPts[n].m_prev}}return-1}handleClosedIntersection(t,i){let n=this.m_offsetPts[this.m_offsetPts[t].m_prev],s=this.m_offsetPts[t],o=this.m_offsetPts[this.m_offsetPts[i].m_prev],h=this.m_offsetPts[i];if(!this.sectGraphicRect(n,s,o,h))return-1;let e=ht();if(((s.x-n.x)*(h.y-o.y)-(s.y-n.y)*(h.x-o.x))*this.m_distance<0&&this.findIntersection(n,s,o,h,e)&&!e.bAtExistingPt){let P=Math.sqrt((s.x-n.x)*(s.x-n.x)+(s.y-n.y)*(s.y-n.y)),_=(s.x-n.x)/P,r=(s.y-n.y)/P,p=Math.sqrt((h.x-o.x)*(h.x-o.x)+(h.y-o.y)*(h.y-o.y)),g=(h.x-o.x)/p,c=(h.y-o.y)/p,f=!1,d=e.pt.clone();d.x+=(_+g)*1e-8,d.y+=(r+c)*1e-8;let u=o,y=e.pt,x=this.m_offsetPts[t].m_prev;for(;y.y>d.y!=u.y>d.y&&d.x<(u.x-y.x)*(d.y-y.y)/(u.y-y.y)+y.x&&(f=!f),u=y,x=this.m_offsetPts[x].m_next,x!==i;)y=this.m_offsetPts[x];if(f)return-1;let v=this.m_offsetPts[t].m_prev;return e.pt.type=s.type,e.pt.m_next=i,e.pt.m_prev=v,this.m_offsetPts[t]=e.pt,this.m_offsetPts[i].m_prev=t,i}return-1}sectGraphicRect(t,i,n,s){return Math.max(t.x,i.x)>=Math.min(n.x,s.x)&&Math.max(n.x,s.x)>=Math.min(t.x,i.x)&&Math.max(t.y,i.y)>=Math.min(n.y,s.y)&&Math.max(n.y,s.y)>=Math.min(t.y,i.y)}findIntersection(t,i,n,s,o){let h,e,m,P;return o.bAtExistingPt=!1,h=(i.y-t.y)*(s.x-n.x)-(i.x-t.x)*(s.y-n.y),e=(n.y-t.y)*(i.x-t.x)-(n.x-t.x)*(i.y-t.y),m=h===0?2:e/h,m>=0&&m<=1&&(P=m,h=(s.y-n.y)*(i.x-t.x)-(s.x-n.x)*(i.y-t.y),e=(t.y-n.y)*(s.x-n.x)-(t.x-n.x)*(s.y-n.y),m=h===0?2:e/h,m>=0&&m<=1)&&(o.pt.x=t.x+m*(i.x-t.x),o.pt.y=t.y+m*(i.y-t.y),this.m_bUseZ&&(o.pt.z=n.z+P*(s.z-n.z)),this.m_bUseM&&(o.pt.m=n.m+P*(s.m-n.m)),P!==0&&P!==1||m!==0&&m!==1||(o.bAtExistingPt=!0),!((P===0||P===1)&&m>0&&m<1||(m===0||m===1)&&P>0&&P<1))}compressOffsetArray(t){for(;this.m_offsetPts[t].m_prev<t;)t=this.m_offsetPts[t].m_prev;let i=0,n=t;do{let s=this.m_offsetPts[n].clone();this.m_offsetPts[i]=s,n=s.m_next,i++}while(n!==t);this.m_offsetPts[i]=this.m_offsetPts[0].clone(),this.m_offsetPtCount=i+1}addPart(t,i){if(!(i<2))for(let n=0;n<i;n++){let s=this.m_offsetPts[t+n];if(n?this.m_bUseZ?this.m_resultPath.lineTo3DCoords(s.x,s.y,s.z):this.m_resultPath.lineToCoords(s.x,s.y):this.m_bUseZ?this.m_resultPath.startPath3DCoords(s.x,s.y,s.z):this.m_resultPath.startPathCoords(s.x,s.y),this.m_bUseM){let o=this.m_resultPath.getPointCount()-1;this.m_resultPath.setAttribute(2,o,0,s.m)}}}offsetMultiPath(t){let i=V(this.m_inputGeometry,0,this.m_tolerance,0,this.m_progressTracker,12e3),n=i.querySegmentIterator();n.resetToFirstPath();let s=-1;for(;n.nextPath();)s++,this.offsetPath(i,s,t)}offsetPath(t,i,n){let s=t.getPathStart(i),o=t.getPathEnd(i);if(this.m_resultPath=n,t.isClosedPath(i)){let h=t.getXY(s);for(;o>s&&t.getXY(o-1).equals(h);)o--;if(o-s>=2){this.m_srcPtCount=o-s,this.m_srcPts.length=this.m_srcPtCount;for(let e=s;e<o;e++)this.progress(),this.m_srcPts[e-s]=M.construct(t.getXY(e),this.m_bUseZ?t.getAttributeAsDbl(1,e,0):0,this.m_bUseM?t.getAttributeAsDbl(2,e,0):0);this.buildOffset()&&this.addPart(0,this.m_offsetPtCount-1)}}else{let h=t.getXY(s);for(;s<o-1&&t.getXY(s+1).equals(h);)s++;let e=t.getXY(o-1);for(;s<o-1&&t.getXY(o-2).equals(e);)o--;if(o-s>=2){this.m_srcPtCount=2*(o-s)-2,this.m_srcPts.length=this.m_srcPtCount;let m=M.construct(h,this.m_bUseZ?t.getAttributeAsDbl(1,s,0):0,this.m_bUseM?t.getAttributeAsDbl(2,s,0):0);m.type|=q+E,this.m_srcPts[0]=m;let P=1,_=this.m_srcPtCount-1;for(let r=s+1;r<o-1;r++,P++,_--)this.progress(),m=M.construct(t.getXY(r),this.m_bUseZ?t.getAttributeAsDbl(1,r,0):0,this.m_bUseM?t.getAttributeAsDbl(2,r,0):0),this.m_srcPts[P]=m.clone(),m.type|=E,this.m_srcPts[_]=m.clone();if(m=M.construct(t.getXY(o-1),this.m_bUseZ?t.getAttributeAsDbl(1,o-1,0):0,this.m_bUseM?t.getAttributeAsDbl(2,o-1,0):0),m.type|=q,this.m_srcPts[P]=m.clone(),this.buildOffset())if(this.m_offsetPts.length>=2){let r=-1,p=-1,g=!!(this.m_offsetPts[this.m_offsetPtCount-1].type&E);g||(r=0);for(let c=1;c<this.m_offsetPtCount;c++){this.progress();let f=!!(this.m_offsetPts[c].type&E);f?g||(p=c-1,p-r+1>1&&this.addPart(r,p-r+1)):g&&(r=c-1),g=f}g||(p=this.m_offsetPtCount-1,p-r+1>1&&this.addPart(r,p-r+1))}else{let p=this.m_offsetPtCount-1;p-0>=1&&this.addPart(0,p-0+1)}}}this.m_srcPts.length=0,this.m_srcPtCount=0,this.m_offsetPts.length=0,this.m_offsetPtCount=0}static dotSign(t,i,n,s){let o=i.x-t.x,h=i.y-t.y,e=s.x-n.x,m=s.y-n.y,P=N(o,h,e,m);return K(P)}},k=class{getOperatorType(){return 10108}accelerateGeometry(t,i,n){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}executeMany(t,i,n,s,o,h,e){return new U(t,i,n,s,o,h,e)}execute(t,i,n,s,o,h,e){return new U(null,i,n,s,o,h,e).offset(t)}},U=class extends F{constructor(t,i,n,s,o,h,e){super(),this.m_progressTracker=e,this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=i,this.m_distance=n,this.m_joins=s,this.m_miterLimit=o,this.m_flattenError=h}tock(){return!0}getRank(){return 1}next(){if(!this.m_inputGeoms)return null;let t;for(;t=this.m_inputGeoms.next();)return this.m_index=this.m_inputGeoms.getGeometryID(),this.offset(t);return null}getGeometryID(){return this.m_index}offset(t){let i;return X(t),i=this.m_flattenError<=0?Q(this.m_spatialReference,t,!0).total():this.m_flattenError,ot(t,this.m_distance,this.m_joins,this.m_miterLimit,i,this.m_progressTracker)}},L=new k;function _t(a,t,i,n,s,o){return L.execute(a,t,i,n,s,o,null)}function dt(a,t,i,n,s,o){let h=L.executeMany(new B(a),t,i,n,s,o,null);return Array.from(h)}function Pt(){return L.supportsCurves()}export{_t as a,dt as b,Pt as c};
